"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Data/Bank.ts":
/*!*********************************!*\
  !*** ./components/Data/Bank.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EDocumentType: function() { return /* binding */ EDocumentType; },\n/* harmony export */   aggregateByDate: function() { return /* binding */ aggregateByDate; },\n/* harmony export */   aggregateByTag: function() { return /* binding */ aggregateByTag; },\n/* harmony export */   aggregateByTags: function() { return /* binding */ aggregateByTags; },\n/* harmony export */   computeQuartileValue: function() { return /* binding */ computeQuartileValue; },\n/* harmony export */   extractBoxPlotFromData: function() { return /* binding */ extractBoxPlotFromData; },\n/* harmony export */   extractIdFromLabel: function() { return /* binding */ extractIdFromLabel; },\n/* harmony export */   extractMainTagsWithCount: function() { return /* binding */ extractMainTagsWithCount; },\n/* harmony export */   extractTags: function() { return /* binding */ extractTags; },\n/* harmony export */   extractTagsWithCount: function() { return /* binding */ extractTagsWithCount; },\n/* harmony export */   getAccountPeriodStr: function() { return /* binding */ getAccountPeriodStr; },\n/* harmony export */   getBankTransferId: function() { return /* binding */ getBankTransferId; },\n/* harmony export */   getBoxPlotsFromLines: function() { return /* binding */ getBoxPlotsFromLines; },\n/* harmony export */   getDirectDebitId: function() { return /* binding */ getDirectDebitId; },\n/* harmony export */   getPaymentId: function() { return /* binding */ getPaymentId; },\n/* harmony export */   getWholePeriod: function() { return /* binding */ getWholePeriod; },\n/* harmony export */   getWithdrawalId: function() { return /* binding */ getWithdrawalId; },\n/* harmony export */   isBankTransferLabel: function() { return /* binding */ isBankTransferLabel; },\n/* harmony export */   isDirectDebitLabel: function() { return /* binding */ isDirectDebitLabel; },\n/* harmony export */   isPaymentLabel: function() { return /* binding */ isPaymentLabel; },\n/* harmony export */   isWithdrawalLabel: function() { return /* binding */ isWithdrawalLabel; },\n/* harmony export */   tagPeriods: function() { return /* binding */ tagPeriods; }\n/* harmony export */ });\nvar EDocumentType;\n(function(EDocumentType) {\n    EDocumentType[\"ACCOUNT\"] = \"ACCOUNT\";\n    EDocumentType[\"MAPPING\"] = \"MAPPING\";\n    EDocumentType[\"BUDGET\"] = \"BUDGET\";\n})(EDocumentType || (EDocumentType = {}));\nfunction aggregateByTags(lines, tagLevel, excludeTag) {\n    let agregate = {};\n    let isRecursive = tagLevel < 0;\n    for(let i = 0; i < lines.length; i++){\n        const line = lines[i];\n        let idx = excludeTag === \"\" ? 0 : line.tags.indexOf(excludeTag);\n        let level = isRecursive ? idx % line.tags.length : tagLevel;\n        let tag = line.tags[level];\n        if (tag === excludeTag && level < line.tags.length - 1) {\n            tag = line.tags[level + 1];\n        } else if (tag === excludeTag && level === line.tags.length - 1) {\n            tag = isRecursive ? line.tags[0] : \"Undefined\";\n        }\n        if (tag in agregate) {\n            var _line_credit;\n            agregate[tag].credit += (_line_credit = line.credit) !== null && _line_credit !== void 0 ? _line_credit : 0;\n            var _line_debit;\n            agregate[tag].debit += (_line_debit = line.debit) !== null && _line_debit !== void 0 ? _line_debit : 0;\n        } else {\n            var _line_credit1, _line_debit1;\n            agregate[tag] = {\n                credit: (_line_credit1 = line.credit) !== null && _line_credit1 !== void 0 ? _line_credit1 : 0,\n                debit: (_line_debit1 = line.debit) !== null && _line_debit1 !== void 0 ? _line_debit1 : 0,\n                subTags: {}\n            };\n        }\n    }\n    return agregate;\n}\nfunction extractTags(lines) {\n    let tags = [];\n    for(let i = 0; i < lines.length; i++){\n        tags.push(...lines[i].tags);\n    }\n    // Remove duplicates\n    tags = tags.filter(function(tag, idx) {\n        return tags.indexOf(tag) === idx;\n    });\n    return tags.sort();\n}\nfunction extractTagsWithCount(lines, startingTag) {\n    let tags = [];\n    for(let i = 0; i < lines.length; i++){\n        let startIdx = 0;\n        let endIdx = lines[i].tags.length;\n        if (startingTag) {\n            // Consider only the next after the startingTag\n            const idx = lines[i].tags.findIndex((tag)=>tag === startingTag);\n            if (idx === lines[i].tags.length - 1) {\n                continue;\n            // If startingTag is the last one in the tag list, consider the first tag of the list instead\n            //startIdx = 0;\n            //endIdx = 1;\n            }\n            startIdx = idx + 1;\n            endIdx = idx + 2;\n            console.log(\"starting tag idx \" + startIdx);\n        }\n        for(let j1 = startIdx; j1 < endIdx; j1++){\n            const tagIdx = tags.findIndex((tag)=>tag.tag === lines[i].tags[j1]);\n            if (tagIdx === -1) {\n                tags.push({\n                    tag: lines[i].tags[j1],\n                    count: 1,\n                    frequency: 1 / lines.length\n                });\n            } else {\n                tags[tagIdx].count++;\n                tags[tagIdx].frequency = tags[tagIdx].count / lines.length;\n            }\n        }\n    }\n    return tags.sort((a, b)=>{\n        const freqA = Math.floor(a.frequency * 100);\n        const freqB = Math.floor(b.frequency * 100);\n        if (freqA === freqB) {\n            return a.tag > b.tag ? 1 : -1;\n        }\n        return Math.floor(b.frequency * 100) - Math.floor(a.frequency * 100);\n    });\n}\nfunction extractMainTagsWithCount(lines) {\n    let tags = [];\n    for(let i = 0; i < lines.length; i++){\n        let startIdx = 0;\n        let endIdx = 0;\n        const tagIdx = tags.findIndex((tag)=>tag.tag === lines[i].tags[j]);\n        if (tagIdx === -1) {\n            tags.push({\n                tag: lines[i].tags[j],\n                count: 1,\n                frequency: 1 / lines.length\n            });\n        } else {\n            tags[tagIdx].count++;\n            tags[tagIdx].frequency = tags[tagIdx].count / lines.length;\n        }\n    }\n    return tags.sort((a, b)=>{\n        const freqA = Math.floor(a.frequency * 100);\n        const freqB = Math.floor(b.frequency * 100);\n        if (freqA === freqB) {\n            return a.tag > b.tag ? 1 : -1;\n        }\n        return Math.floor(b.frequency * 100) - Math.floor(a.frequency * 100);\n    });\n}\nfunction aggregateByTag(lines, tag) {\n    let agregate = {};\n    const taggedLines = tag === \"\" ? lines : lines.filter((line)=>line.tags.indexOf(tag) !== -1);\n    for(let i = 0; i < taggedLines.length; i++){\n        const line = taggedLines[i];\n        if (tag in agregate) {\n            var _line_credit;\n            agregate[tag].credit += (_line_credit = line.credit) !== null && _line_credit !== void 0 ? _line_credit : 0;\n            var _line_debit;\n            agregate[tag].debit += (_line_debit = line.debit) !== null && _line_debit !== void 0 ? _line_debit : 0;\n        } else {\n            var _line_credit1, _line_debit1;\n            agregate[tag] = {\n                credit: (_line_credit1 = line.credit) !== null && _line_credit1 !== void 0 ? _line_credit1 : 0,\n                debit: (_line_debit1 = line.debit) !== null && _line_debit1 !== void 0 ? _line_debit1 : 0,\n                subTags: {}\n            };\n        }\n    }\n    agregate[tag].subTags = aggregateByTags(taggedLines, 0, tag);\n    return agregate;\n}\nfunction aggregateByDate(lines) {\n    let monthly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    let agregate = {};\n    for(let i = 0; i < lines.length; i++){\n        const line = lines[i];\n        let strDate = line.date.toLocaleDateString(\"fr-FR\");\n        if (monthly) {\n            strDate = strDate.slice(strDate.indexOf(\"/\") + 1);\n        }\n        if (strDate in agregate) {\n            var _line_credit;\n            agregate[strDate].credit += (_line_credit = line.credit) !== null && _line_credit !== void 0 ? _line_credit : 0;\n            var _line_debit;\n            agregate[strDate].debit += (_line_debit = line.debit) !== null && _line_debit !== void 0 ? _line_debit : 0;\n        } else {\n            var _line_credit1, _line_debit1;\n            agregate[strDate] = {\n                credit: (_line_credit1 = line.credit) !== null && _line_credit1 !== void 0 ? _line_credit1 : 0,\n                debit: (_line_debit1 = line.debit) !== null && _line_debit1 !== void 0 ? _line_debit1 : 0,\n                subTags: {}\n            };\n        }\n    }\n    return agregate;\n}\nfunction getAccountPeriodStr(account) {\n    let aggregatedMention = account.isAggregated ? \" (Aggregated) \" : \"\";\n    return account.begin.toLocaleDateString() + \" - \" + account.end.toLocaleDateString() + aggregatedMention;\n}\nfunction getWholePeriod(accounts) {\n    const wholePeriod = accounts.reduce((result, period)=>{\n        return {\n            ...result,\n            begin: period.begin < result.begin ? period.begin : result.begin,\n            end: period.begin > result.begin ? period.begin : result.begin,\n            lines: [\n                ...result.lines,\n                ...period.lines\n            ],\n            isAggregated: true\n        };\n    });\n    wholePeriod.lines.sort((a, b)=>{\n        return a.date.getTime() === b.date.getTime() ? 0 : a.date.getTime() > b.date.getTime() ? 1 : -1;\n    });\n    return wholePeriod;\n}\nfunction isPaymentLabel(label) {\n    const regExp = new RegExp(/(PAIEMENT\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction isDirectDebitLabel(label) {\n    const regExp = new RegExp(/(PRLV\\sSEPA\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction isBankTransferLabel(label) {\n    const regExp = new RegExp(/(VIR\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction isWithdrawalLabel(label) {\n    const regExp = new RegExp(/(RETRAIT\\sDAB\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction getPaymentId(label) {\n    //PAIEMENT CB 3007 FR LYON LA-BARGE CARTE 2178\n    const matches = label.toUpperCase().match(/(?:PAIEMENT\\s(?:CB|PSC)\\s\\d\\d\\d\\d\\s)(([a-zA-Z]|-|_|\\d+|\\/|\\*|\\s)+)(?:CARTE\\s\\d\\d\\d\\d)/);\n    return matches ? matches[1] : \"\";\n}\nfunction getDirectDebitId(label) {\n    const matches = label.toUpperCase().match(/(?:PRLV\\sSEPA\\s)(([a-zA-Z]|-|_|\\s)+)/);\n    return matches ? matches[1] : \"\";\n}\nfunction getBankTransferId(label) {\n    const matches = label.toUpperCase().match(/(?:VIR\\s)(([a-zA-Z]|-|_|\\s)+)/);\n    return matches ? matches[1] : \"\";\n}\nfunction getWithdrawalId(label) {\n    const matches = label.toUpperCase().match(/RETRAIT DAB/);\n    return matches ? matches[0] : \"\";\n}\nfunction extractIdFromLabel(label) {\n    if (isBankTransferLabel(label)) {\n        return getBankTransferId(label).trim();\n    }\n    if (isPaymentLabel(label)) {\n        return getPaymentId(label).trim();\n    }\n    if (isDirectDebitLabel(label)) {\n        return getDirectDebitId(label).trim();\n    }\n    if (isWithdrawalLabel(label)) {\n        return getWithdrawalId(label).trim();\n    }\n    return label.trim();\n}\nfunction tagPeriods(periods, mapping) {\n    const taggedPeriods = [\n        ...periods\n    ];\n    for(let i = 0; i < taggedPeriods.length; i++){\n        const period = taggedPeriods[i];\n        for(let j1 = 0; j1 < period.lines.length; j1++){\n            const line = period.lines[j1];\n            const id = extractIdFromLabel(line.label);\n            if (mapping[id]) {\n                line.tags = mapping[id].split(\">\");\n            }\n        }\n    }\n    return taggedPeriods;\n}\nfunction getBoxPlotsFromLines(allAccountLines) {\n    const step = 10;\n    const boxPlotByStep = [];\n    let values = allAccountLines.filter((line)=>line.pctInMonth < 5).map((line)=>line.balance).sort((a, b)=>a - b);\n    let boxPlot = extractBoxPlotFromData(values);\n    boxPlot.pctInMonth = 1;\n    boxPlotByStep.push(boxPlot);\n    for(let i = 5; i <= 95; i += step){\n        let values = allAccountLines.filter((line)=>line.pctInMonth >= i - 5 && line.pctInMonth < i + 5).map((line)=>line.balance).sort((a, b)=>a - b);\n        const boxPlot = extractBoxPlotFromData(values);\n        boxPlot.pctInMonth = i;\n        boxPlotByStep.push(boxPlot);\n    }\n    values = allAccountLines.filter((line)=>line.pctInMonth >= 95).map((line)=>line.balance).sort((a, b)=>a - b);\n    boxPlot = extractBoxPlotFromData(values);\n    boxPlot.pctInMonth = 100;\n    boxPlotByStep.push(boxPlot);\n    return boxPlotByStep;\n}\nfunction extractBoxPlotFromData(data) {\n    if (data.length === 0) {\n        return {\n            pctInMonth: NaN,\n            firstQuartile: NaN,\n            thirdQuartile: NaN,\n            mediane: NaN,\n            mean: NaN,\n            minimum: NaN,\n            maximum: NaN\n        };\n    }\n    const firstQuartileIdx = Math.max(0, (data.length + 3) / 4 - 1);\n    const thirdQuartileIdx = Math.max(0, (3 * data.length + 1) / 4 - 1);\n    let mediane;\n    if (data.length % 2 === 0 && data.length > 2) {\n        const lowerIdx = data.length / 2 - 2;\n        const upperIdx = data.length / 2 - 1;\n        mediane = (data[lowerIdx] + data[upperIdx]) / 2;\n    } else {\n        const idx = Math.max(0, (data.length + 1) / 2 - 1);\n        mediane = data[idx];\n    }\n    let mean = 0;\n    mean = data.reduce((a, b)=>a + b);\n    mean = mean / data.length;\n    return {\n        pctInMonth: NaN,\n        firstQuartile: computeQuartileValue(firstQuartileIdx, data),\n        thirdQuartile: computeQuartileValue(thirdQuartileIdx, data),\n        mediane: mediane,\n        mean: mean,\n        minimum: data[0],\n        maximum: data[data.length - 1]\n    };\n}\nfunction computeQuartileValue(quartileIdx, data) {\n    if (Number.isInteger(quartileIdx)) {\n        return data[quartileIdx];\n    }\n    const lowerIdx = Math.ceil(quartileIdx);\n    const upperIdx = Math.floor(quartileIdx);\n    let coeff1 = 1;\n    let coeff2 = 1;\n    if (quartileIdx - lowerIdx === 0.25) {\n        coeff1 = 3;\n    } else if (quartileIdx - lowerIdx === 0.75) {\n        coeff2 = 3;\n    }\n    // else {  (quartileIdx - lowerIdx === 0.5) {\n    //coeff1 = 1, coeff2 = 1\n    return (data[lowerIdx] * coeff1 + data[upperIdx] * coeff2) / (coeff1 + coeff2);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvRGF0YS9CYW5rLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VBaURZQTs7OztHQUFBQSxrQkFBQUE7QUFNTCxTQUFTQyxnQkFBZ0JDLEtBQXFCLEVBQUVDLFFBQWdCLEVBQUVDLFVBQWtCO0lBQ3ZGLElBQUlDLFdBQW9CLENBQUM7SUFDekIsSUFBSUMsY0FBY0gsV0FBVztJQUU3QixJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSUwsTUFBTU0sTUFBTSxFQUFFRCxJQUFLO1FBQ25DLE1BQU1FLE9BQU9QLEtBQUssQ0FBQ0ssRUFBRTtRQUVyQixJQUFJRyxNQUFNTixlQUFlLEtBQUssSUFBSUssS0FBS0UsSUFBSSxDQUFDQyxPQUFPLENBQUNSO1FBQ3BELElBQUlTLFFBQVFQLGNBQWVJLE1BQU1ELEtBQUtFLElBQUksQ0FBQ0gsTUFBTSxHQUFJTDtRQUNyRCxJQUFJVyxNQUFNTCxLQUFLRSxJQUFJLENBQUNFLE1BQU07UUFFMUIsSUFBSUMsUUFBUVYsY0FBY1MsUUFBU0osS0FBS0UsSUFBSSxDQUFDSCxNQUFNLEdBQUcsR0FBSTtZQUN0RE0sTUFBTUwsS0FBS0UsSUFBSSxDQUFDRSxRQUFRLEVBQUU7UUFDOUIsT0FDSyxJQUFJQyxRQUFRVixjQUFjUyxVQUFXSixLQUFLRSxJQUFJLENBQUNILE1BQU0sR0FBRyxHQUFJO1lBQzdETSxNQUFNUixjQUFjRyxLQUFLRSxJQUFJLENBQUMsRUFBRSxHQUFHO1FBQ3ZDO1FBRUEsSUFBSUcsT0FBT1QsVUFBVTtnQkFDT0k7WUFBeEJKLFFBQVEsQ0FBQ1MsSUFBSSxDQUFDQyxNQUFNLElBQUlOLENBQUFBLGVBQUFBLEtBQUtNLE1BQU0sY0FBWE4sMEJBQUFBLGVBQWU7Z0JBQ2hCQTtZQUF2QkosUUFBUSxDQUFDUyxJQUFJLENBQUNFLEtBQUssSUFBSVAsQ0FBQUEsY0FBQUEsS0FBS08sS0FBSyxjQUFWUCx5QkFBQUEsY0FBYztRQUN6QyxPQUNLO2dCQUVXQSxlQUNEQTtZQUZYSixRQUFRLENBQUNTLElBQUksR0FBRztnQkFDWkMsUUFBUU4sQ0FBQUEsZ0JBQUFBLEtBQUtNLE1BQU0sY0FBWE4sMkJBQUFBLGdCQUFlO2dCQUN2Qk8sT0FBT1AsQ0FBQUEsZUFBQUEsS0FBS08sS0FBSyxjQUFWUCwwQkFBQUEsZUFBYztnQkFDckJRLFNBQVMsQ0FBQztZQUNkO1FBQ0o7SUFDSjtJQUVBLE9BQU9aO0FBQ1g7QUFFTyxTQUFTYSxZQUFZaEIsS0FBcUI7SUFDN0MsSUFBSVMsT0FBaUIsRUFBRTtJQUN2QixJQUFLLElBQUlKLElBQUksR0FBR0EsSUFBSUwsTUFBTU0sTUFBTSxFQUFFRCxJQUFLO1FBQ25DSSxLQUFLUSxJQUFJLElBQUlqQixLQUFLLENBQUNLLEVBQUUsQ0FBQ0ksSUFBSTtJQUM5QjtJQUVBLG9CQUFvQjtJQUNwQkEsT0FBT0EsS0FBS1MsTUFBTSxDQUFDLFNBQVNOLEdBQUcsRUFBRUosR0FBRztRQUNoQyxPQUFPQyxLQUFLQyxPQUFPLENBQUNFLFNBQVNKO0lBQ2pDO0lBRUEsT0FBT0MsS0FBS1UsSUFBSTtBQUNwQjtBQUVPLFNBQVNDLHFCQUFxQnBCLEtBQXFCLEVBQUVxQixXQUErQjtJQUN2RixJQUFJWixPQUFlLEVBQUU7SUFFckIsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUlMLE1BQU1NLE1BQU0sRUFBRUQsSUFBSztRQUNuQyxJQUFJaUIsV0FBVztRQUNmLElBQUlDLFNBQVN2QixLQUFLLENBQUNLLEVBQUUsQ0FBQ0ksSUFBSSxDQUFDSCxNQUFNO1FBRWpDLElBQUllLGFBQWE7WUFDYiwrQ0FBK0M7WUFDL0MsTUFBTWIsTUFBTVIsS0FBSyxDQUFDSyxFQUFFLENBQUNJLElBQUksQ0FBQ2UsU0FBUyxDQUFDLENBQUNaLE1BQVFBLFFBQVFTO1lBQ3JELElBQUliLFFBQVNSLEtBQUssQ0FBQ0ssRUFBRSxDQUFDSSxJQUFJLENBQUNILE1BQU0sR0FBRyxHQUFJO2dCQUVwQztZQUNBLDZGQUE2RjtZQUM3RixlQUFlO1lBQ2YsYUFBYTtZQUNqQjtZQUVBZ0IsV0FBV2QsTUFBTTtZQUNqQmUsU0FBU2YsTUFBTTtZQUNmaUIsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQko7UUFDdEM7UUFFQSxJQUFLLElBQUlLLEtBQUlMLFVBQVVLLEtBQUlKLFFBQVFJLEtBQUs7WUFDcEMsTUFBTUMsU0FBU25CLEtBQUtlLFNBQVMsQ0FBQyxDQUFDWixNQUFRQSxJQUFJQSxHQUFHLEtBQUtaLEtBQUssQ0FBQ0ssRUFBRSxDQUFDSSxJQUFJLENBQUNrQixHQUFFO1lBQ25FLElBQUlDLFdBQVcsQ0FBQyxHQUFHO2dCQUNmbkIsS0FBS1EsSUFBSSxDQUFDO29CQUFDTCxLQUFLWixLQUFLLENBQUNLLEVBQUUsQ0FBQ0ksSUFBSSxDQUFDa0IsR0FBRTtvQkFBRUUsT0FBTztvQkFBR0MsV0FBVyxJQUFFOUIsTUFBTU0sTUFBTTtnQkFBQTtZQUN6RSxPQUNLO2dCQUNERyxJQUFJLENBQUNtQixPQUFPLENBQUNDLEtBQUs7Z0JBQ2xCcEIsSUFBSSxDQUFDbUIsT0FBTyxDQUFDRSxTQUFTLEdBQUdyQixJQUFJLENBQUNtQixPQUFPLENBQUNDLEtBQUssR0FBQzdCLE1BQU1NLE1BQU07WUFDNUQ7UUFDSjtJQUNKO0lBRUEsT0FBT0csS0FBS1UsSUFBSSxDQUFDLENBQUNZLEdBQUdDO1FBQ2pCLE1BQU1DLFFBQVFDLEtBQUtDLEtBQUssQ0FBQ0osRUFBRUQsU0FBUyxHQUFHO1FBQ3ZDLE1BQU1NLFFBQVFGLEtBQUtDLEtBQUssQ0FBQ0gsRUFBRUYsU0FBUyxHQUFHO1FBQ3ZDLElBQUlHLFVBQVVHLE9BQU87WUFDakIsT0FBT0wsRUFBRW5CLEdBQUcsR0FBR29CLEVBQUVwQixHQUFHLEdBQUcsSUFBSSxDQUFDO1FBQ2hDO1FBQ0EsT0FBUXNCLEtBQUtDLEtBQUssQ0FBQ0gsRUFBRUYsU0FBUyxHQUFHLE9BQU9JLEtBQUtDLEtBQUssQ0FBQ0osRUFBRUQsU0FBUyxHQUFHO0lBQ3JFO0FBQ0o7QUFFTyxTQUFTTyx5QkFBeUJyQyxLQUFxQjtJQUMxRCxJQUFJUyxPQUFlLEVBQUU7SUFFckIsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUlMLE1BQU1NLE1BQU0sRUFBRUQsSUFBSztRQUNuQyxJQUFJaUIsV0FBVztRQUNmLElBQUlDLFNBQVM7UUFFYixNQUFNSyxTQUFTbkIsS0FBS2UsU0FBUyxDQUFDLENBQUNaLE1BQVFBLElBQUlBLEdBQUcsS0FBS1osS0FBSyxDQUFDSyxFQUFFLENBQUNJLElBQUksQ0FBQ2tCLEVBQUU7UUFDL0QsSUFBSUMsV0FBVyxDQUFDLEdBQUc7WUFDZm5CLEtBQUtRLElBQUksQ0FBQztnQkFBQ0wsS0FBS1osS0FBSyxDQUFDSyxFQUFFLENBQUNJLElBQUksQ0FBQ2tCLEVBQUU7Z0JBQUVFLE9BQU87Z0JBQUdDLFdBQVcsSUFBRTlCLE1BQU1NLE1BQU07WUFBQTtRQUN6RSxPQUNLO1lBQ0RHLElBQUksQ0FBQ21CLE9BQU8sQ0FBQ0MsS0FBSztZQUNsQnBCLElBQUksQ0FBQ21CLE9BQU8sQ0FBQ0UsU0FBUyxHQUFHckIsSUFBSSxDQUFDbUIsT0FBTyxDQUFDQyxLQUFLLEdBQUM3QixNQUFNTSxNQUFNO1FBQzVEO0lBQ1I7SUFFQSxPQUFPRyxLQUFLVSxJQUFJLENBQUMsQ0FBQ1ksR0FBR0M7UUFDakIsTUFBTUMsUUFBUUMsS0FBS0MsS0FBSyxDQUFDSixFQUFFRCxTQUFTLEdBQUc7UUFDdkMsTUFBTU0sUUFBUUYsS0FBS0MsS0FBSyxDQUFDSCxFQUFFRixTQUFTLEdBQUc7UUFDdkMsSUFBSUcsVUFBVUcsT0FBTztZQUNqQixPQUFPTCxFQUFFbkIsR0FBRyxHQUFHb0IsRUFBRXBCLEdBQUcsR0FBRyxJQUFJLENBQUM7UUFDaEM7UUFDQSxPQUFRc0IsS0FBS0MsS0FBSyxDQUFDSCxFQUFFRixTQUFTLEdBQUcsT0FBT0ksS0FBS0MsS0FBSyxDQUFDSixFQUFFRCxTQUFTLEdBQUc7SUFDckU7QUFDSjtBQUVPLFNBQVNRLGVBQWV0QyxLQUFxQixFQUFFWSxHQUFXO0lBQzdELElBQUlULFdBQW9CLENBQUM7SUFDekIsTUFBTW9DLGNBQWMzQixRQUFRLEtBQUtaLFFBQVFBLE1BQU1rQixNQUFNLENBQUMsQ0FBQ1gsT0FBU0EsS0FBS0UsSUFBSSxDQUFDQyxPQUFPLENBQUNFLFNBQVMsQ0FBQztJQUU1RixJQUFLLElBQUlQLElBQUksR0FBR0EsSUFBSWtDLFlBQVlqQyxNQUFNLEVBQUVELElBQUs7UUFDekMsTUFBTUUsT0FBT2dDLFdBQVcsQ0FBQ2xDLEVBQUU7UUFDM0IsSUFBSU8sT0FBT1QsVUFBVTtnQkFDT0k7WUFBeEJKLFFBQVEsQ0FBQ1MsSUFBSSxDQUFDQyxNQUFNLElBQUlOLENBQUFBLGVBQUFBLEtBQUtNLE1BQU0sY0FBWE4sMEJBQUFBLGVBQWU7Z0JBQ2hCQTtZQUF2QkosUUFBUSxDQUFDUyxJQUFJLENBQUNFLEtBQUssSUFBSVAsQ0FBQUEsY0FBQUEsS0FBS08sS0FBSyxjQUFWUCx5QkFBQUEsY0FBYztRQUN6QyxPQUNLO2dCQUVXQSxlQUNEQTtZQUZYSixRQUFRLENBQUNTLElBQUksR0FBRztnQkFDWkMsUUFBUU4sQ0FBQUEsZ0JBQUFBLEtBQUtNLE1BQU0sY0FBWE4sMkJBQUFBLGdCQUFlO2dCQUN2Qk8sT0FBT1AsQ0FBQUEsZUFBQUEsS0FBS08sS0FBSyxjQUFWUCwwQkFBQUEsZUFBYztnQkFDckJRLFNBQVMsQ0FBQztZQUNkO1FBQ0o7SUFDSjtJQUNBWixRQUFRLENBQUNTLElBQUksQ0FBQ0csT0FBTyxHQUFHaEIsZ0JBQWdCd0MsYUFBYSxHQUFHM0I7SUFDeEQsT0FBT1Q7QUFDWDtBQUVPLFNBQVNxQyxnQkFBZ0J4QyxLQUFxQjtRQUFFeUMsVUFBQUEsaUVBQW1CO0lBQ3RFLElBQUl0QyxXQUFvQixDQUFDO0lBRXpCLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7UUFDbkMsTUFBTUUsT0FBT1AsS0FBSyxDQUFDSyxFQUFFO1FBQ3JCLElBQUlxQyxVQUFVbkMsS0FBS29DLElBQUksQ0FBQ0Msa0JBQWtCLENBQUM7UUFDM0MsSUFBSUgsU0FBUztZQUNUQyxVQUFVQSxRQUFRRyxLQUFLLENBQUNILFFBQVFoQyxPQUFPLENBQUMsT0FBSztRQUNqRDtRQUVBLElBQUlnQyxXQUFXdkMsVUFBVTtnQkFDT0k7WUFBNUJKLFFBQVEsQ0FBQ3VDLFFBQVEsQ0FBQzdCLE1BQU0sSUFBSU4sQ0FBQUEsZUFBQUEsS0FBS00sTUFBTSxjQUFYTiwwQkFBQUEsZUFBZTtnQkFDaEJBO1lBQTNCSixRQUFRLENBQUN1QyxRQUFRLENBQUM1QixLQUFLLElBQUlQLENBQUFBLGNBQUFBLEtBQUtPLEtBQUssY0FBVlAseUJBQUFBLGNBQWM7UUFDN0MsT0FDSztnQkFFV0EsZUFDREE7WUFGWEosUUFBUSxDQUFDdUMsUUFBUSxHQUFHO2dCQUNoQjdCLFFBQVFOLENBQUFBLGdCQUFBQSxLQUFLTSxNQUFNLGNBQVhOLDJCQUFBQSxnQkFBZTtnQkFDdkJPLE9BQU9QLENBQUFBLGVBQUFBLEtBQUtPLEtBQUssY0FBVlAsMEJBQUFBLGVBQWM7Z0JBQ3JCUSxTQUFTLENBQUM7WUFDZDtRQUNKO0lBQ0o7SUFDQSxPQUFPWjtBQUNYO0FBRU8sU0FBUzJDLG9CQUFvQkMsT0FBdUI7SUFDdkQsSUFBSUMsb0JBQW9CRCxRQUFRRSxZQUFZLEdBQUcsbUJBQW1CO0lBQ2xFLE9BQU9GLFFBQVFHLEtBQUssQ0FBQ04sa0JBQWtCLEtBQUssUUFBUUcsUUFBUUksR0FBRyxDQUFDUCxrQkFBa0IsS0FBS0k7QUFDM0Y7QUFFTyxTQUFTSSxlQUFlQyxRQUEwQjtJQUNyRCxNQUFNQyxjQUE4QkQsU0FBU0UsTUFBTSxDQUFDLENBQUNDLFFBQVFDO1FBQ3pELE9BQU87WUFBQyxHQUFHRCxNQUFNO1lBQ2JOLE9BQU9PLE9BQU9QLEtBQUssR0FBR00sT0FBT04sS0FBSyxHQUFHTyxPQUFPUCxLQUFLLEdBQUdNLE9BQU9OLEtBQUs7WUFDaEVDLEtBQUtNLE9BQU9QLEtBQUssR0FBR00sT0FBT04sS0FBSyxHQUFHTyxPQUFPUCxLQUFLLEdBQUdNLE9BQU9OLEtBQUs7WUFDOURsRCxPQUFPO21CQUFJd0QsT0FBT3hELEtBQUs7bUJBQUt5RCxPQUFPekQsS0FBSzthQUFDO1lBQ3pDaUQsY0FBYztRQUFJO0lBQ3hCO0lBRUFLLFlBQVl0RCxLQUFLLENBQUNtQixJQUFJLENBQUMsQ0FBQ1ksR0FBaUJDO1FBQXFCLE9BQU9ELEVBQUVZLElBQUksQ0FBQ2UsT0FBTyxPQUFPMUIsRUFBRVcsSUFBSSxDQUFDZSxPQUFPLEtBQUssSUFBSzNCLEVBQUVZLElBQUksQ0FBQ2UsT0FBTyxLQUFLMUIsRUFBRVcsSUFBSSxDQUFDZSxPQUFPLEtBQUssSUFBSSxDQUFDO0lBQUc7SUFDbEssT0FBT0o7QUFDWDtBQUVPLFNBQVNLLGVBQWVDLEtBQWE7SUFDeEMsTUFBTUMsU0FBUyxJQUFJQyxPQUFPO0lBQzFCLE1BQU1DLE9BQU9GLE9BQU9FLElBQUksQ0FBQ0gsTUFBTUksV0FBVztJQUMxQyxPQUFPRDtBQUNYO0FBRU8sU0FBU0UsbUJBQW1CTCxLQUFhO0lBQzVDLE1BQU1DLFNBQVMsSUFBSUMsT0FBTztJQUMxQixNQUFNQyxPQUFPRixPQUFPRSxJQUFJLENBQUNILE1BQU1JLFdBQVc7SUFDMUMsT0FBT0Q7QUFDWDtBQUVPLFNBQVNHLG9CQUFvQk4sS0FBYTtJQUM3QyxNQUFNQyxTQUFTLElBQUlDLE9BQU87SUFDMUIsTUFBTUMsT0FBT0YsT0FBT0UsSUFBSSxDQUFDSCxNQUFNSSxXQUFXO0lBQzFDLE9BQU9EO0FBQ1g7QUFFTyxTQUFTSSxrQkFBa0JQLEtBQWE7SUFDM0MsTUFBTUMsU0FBUyxJQUFJQyxPQUFPO0lBQzFCLE1BQU1DLE9BQU9GLE9BQU9FLElBQUksQ0FBQ0gsTUFBTUksV0FBVztJQUMxQyxPQUFPRDtBQUNYO0FBRU8sU0FBU0ssYUFBYVIsS0FBYTtJQUN0Qyw4Q0FBOEM7SUFDOUMsTUFBTVMsVUFBVVQsTUFBTUksV0FBVyxHQUFHTSxLQUFLLENBQUM7SUFDMUMsT0FBT0QsVUFBVUEsT0FBTyxDQUFDLEVBQUUsR0FBRztBQUNsQztBQUVPLFNBQVNFLGlCQUFpQlgsS0FBYTtJQUMxQyxNQUFNUyxVQUFVVCxNQUFNSSxXQUFXLEdBQUdNLEtBQUssQ0FBQztJQUMxQyxPQUFPRCxVQUFVQSxPQUFPLENBQUMsRUFBRSxHQUFHO0FBQ2xDO0FBRU8sU0FBU0csa0JBQWtCWixLQUFhO0lBQzNDLE1BQU1TLFVBQVVULE1BQU1JLFdBQVcsR0FBR00sS0FBSyxDQUFDO0lBQzFDLE9BQU9ELFVBQVVBLE9BQU8sQ0FBQyxFQUFFLEdBQUc7QUFDbEM7QUFFTyxTQUFTSSxnQkFBZ0JiLEtBQWE7SUFDekMsTUFBTVMsVUFBVVQsTUFBTUksV0FBVyxHQUFHTSxLQUFLLENBQUM7SUFDMUMsT0FBT0QsVUFBVUEsT0FBTyxDQUFDLEVBQUUsR0FBRztBQUNsQztBQUVPLFNBQVNLLG1CQUFtQmQsS0FBYTtJQUM1QyxJQUFJTSxvQkFBb0JOLFFBQVE7UUFDNUIsT0FBT1ksa0JBQWtCWixPQUFPZSxJQUFJO0lBQ3hDO0lBRUEsSUFBSWhCLGVBQWVDLFFBQVE7UUFDdkIsT0FBT1EsYUFBYVIsT0FBT2UsSUFBSTtJQUNuQztJQUVBLElBQUlWLG1CQUFtQkwsUUFBUTtRQUMzQixPQUFPVyxpQkFBaUJYLE9BQU9lLElBQUk7SUFDdkM7SUFFQSxJQUFJUixrQkFBa0JQLFFBQVE7UUFDMUIsT0FBT2EsZ0JBQWdCYixPQUFPZSxJQUFJO0lBQ3RDO0lBRUEsT0FBT2YsTUFBTWUsSUFBSTtBQUNyQjtBQUVPLFNBQVNDLFdBQVdDLE9BQXlCLEVBQUVDLE9BQWlCO0lBQ25FLE1BQU1DLGdCQUFnQjtXQUFJRjtLQUFRO0lBQ2xDLElBQUssSUFBSXhFLElBQUksR0FBR0EsSUFBSTBFLGNBQWN6RSxNQUFNLEVBQUVELElBQUs7UUFDM0MsTUFBTW9ELFNBQVNzQixhQUFhLENBQUMxRSxFQUFFO1FBQy9CLElBQUssSUFBSXNCLEtBQUksR0FBR0EsS0FBSThCLE9BQU96RCxLQUFLLENBQUNNLE1BQU0sRUFBRXFCLEtBQUs7WUFDMUMsTUFBTXBCLE9BQU9rRCxPQUFPekQsS0FBSyxDQUFDMkIsR0FBRTtZQUM1QixNQUFNcUQsS0FBS04sbUJBQW1CbkUsS0FBS3FELEtBQUs7WUFDeEMsSUFBSWtCLE9BQU8sQ0FBQ0UsR0FBRyxFQUFFO2dCQUNiekUsS0FBS0UsSUFBSSxHQUFHcUUsT0FBTyxDQUFDRSxHQUFHLENBQUNDLEtBQUssQ0FBQztZQUNsQztRQUNKO0lBQ0o7SUFDQSxPQUFPRjtBQUNYO0FBWU8sU0FBU0cscUJBQXFCQyxlQUErQjtJQUNoRSxNQUFNQyxPQUFPO0lBQ2IsTUFBTUMsZ0JBQTRCLEVBQUU7SUFFcEMsSUFBSUMsU0FBU0gsZ0JBQWdCakUsTUFBTSxDQUFDLENBQUNYLE9BQVNBLEtBQUtnRixVQUFVLEdBQUcsR0FBR0MsR0FBRyxDQUFDLENBQUNqRixPQUFTQSxLQUFLa0YsT0FBTyxFQUFFdEUsSUFBSSxDQUFDLENBQUNZLEdBQUVDLElBQU1ELElBQUVDO0lBQy9HLElBQUkwRCxVQUFVQyx1QkFBdUJMO0lBQ3JDSSxRQUFRSCxVQUFVLEdBQUc7SUFDckJGLGNBQWNwRSxJQUFJLENBQUN5RTtJQUVuQixJQUFLLElBQUlyRixJQUFJLEdBQUdBLEtBQUssSUFBSUEsS0FBRytFLEtBQU07UUFDOUIsSUFBSUUsU0FBU0gsZ0JBQWdCakUsTUFBTSxDQUFDLENBQUNYLE9BQVNBLEtBQUtnRixVQUFVLElBQUtsRixJQUFFLEtBQU1FLEtBQUtnRixVQUFVLEdBQUlsRixJQUFFLEdBQUltRixHQUFHLENBQUMsQ0FBQ2pGLE9BQVNBLEtBQUtrRixPQUFPLEVBQUV0RSxJQUFJLENBQUMsQ0FBQ1ksR0FBRUMsSUFBTUQsSUFBRUM7UUFDL0ksTUFBTTBELFVBQVVDLHVCQUF1Qkw7UUFDdkNJLFFBQVFILFVBQVUsR0FBR2xGO1FBQ3JCZ0YsY0FBY3BFLElBQUksQ0FBQ3lFO0lBQ3ZCO0lBRUFKLFNBQVNILGdCQUFnQmpFLE1BQU0sQ0FBQyxDQUFDWCxPQUFTQSxLQUFLZ0YsVUFBVSxJQUFJLElBQUlDLEdBQUcsQ0FBQyxDQUFDakYsT0FBU0EsS0FBS2tGLE9BQU8sRUFBRXRFLElBQUksQ0FBQyxDQUFDWSxHQUFFQyxJQUFNRCxJQUFFQztJQUM3RzBELFVBQVVDLHVCQUF1Qkw7SUFDakNJLFFBQVFILFVBQVUsR0FBRztJQUNyQkYsY0FBY3BFLElBQUksQ0FBQ3lFO0lBRW5CLE9BQU9MO0FBQ1g7QUFFTyxTQUFTTSx1QkFBdUJDLElBQWM7SUFFakQsSUFBSUEsS0FBS3RGLE1BQU0sS0FBSyxHQUFHO1FBQ25CLE9BQU87WUFDSGlGLFlBQVlNO1lBQ1pDLGVBQWVEO1lBQ2ZFLGVBQWVGO1lBQ2ZHLFNBQVNIO1lBQ1RJLE1BQU1KO1lBQ05LLFNBQVNMO1lBQ1RNLFNBQVNOO1FBQ2I7SUFDSjtJQUVBLE1BQU1PLG1CQUFtQmxFLEtBQUttRSxHQUFHLENBQUMsR0FBRyxDQUFFVCxLQUFLdEYsTUFBTSxHQUFHLEtBQUssSUFBSTtJQUM5RCxNQUFNZ0csbUJBQW1CcEUsS0FBS21FLEdBQUcsQ0FBQyxHQUFHLENBQUUsSUFBSVQsS0FBS3RGLE1BQU0sR0FBRyxLQUFLLElBQUk7SUFFbEUsSUFBSTBGO0lBQ0osSUFBSUosS0FBS3RGLE1BQU0sR0FBRyxNQUFNLEtBQUtzRixLQUFLdEYsTUFBTSxHQUFHLEdBQUc7UUFDMUMsTUFBTWlHLFdBQVcsS0FBT2pHLE1BQU0sR0FBSSxJQUFLO1FBQ3ZDLE1BQU1rRyxXQUFXLEtBQU9sRyxNQUFNLEdBQUksSUFBSztRQUN2QzBGLFVBQVUsQ0FBQ0osSUFBSSxDQUFDVyxTQUFTLEdBQUdYLElBQUksQ0FBQ1ksU0FBUyxJQUFJO0lBQ2xELE9BQ0s7UUFDRixNQUFNaEcsTUFBTTBCLEtBQUttRSxHQUFHLENBQUMsR0FBRyxDQUFFVCxLQUFLdEYsTUFBTSxHQUFHLEtBQUssSUFBSTtRQUNqRDBGLFVBQVVKLElBQUksQ0FBQ3BGLElBQUk7SUFDdEI7SUFFQSxJQUFJeUYsT0FBZTtJQUNuQkEsT0FBT0wsS0FBS3JDLE1BQU0sQ0FBQyxDQUFDeEIsR0FBR0MsSUFBTUQsSUFBR0M7SUFDaENpRSxPQUFPQSxPQUFPTCxLQUFLdEYsTUFBTTtJQUV6QixPQUFPO1FBQ0hpRixZQUFZTTtRQUNaQyxlQUFlVyxxQkFBcUJMLGtCQUFrQlI7UUFDdERHLGVBQWVVLHFCQUFxQkgsa0JBQWtCVjtRQUN0REksU0FBU0E7UUFDVEMsTUFBTUE7UUFDTkMsU0FBU04sSUFBSSxDQUFDLEVBQUU7UUFDaEJPLFNBQVNQLElBQUksQ0FBQ0EsS0FBS3RGLE1BQU0sR0FBRyxFQUFFO0lBQ2xDO0FBQ0o7QUFFTyxTQUFTbUcscUJBQXFCQyxXQUFtQixFQUFFZCxJQUFjO0lBQ3BFLElBQUllLE9BQU9DLFNBQVMsQ0FBQ0YsY0FBYztRQUMvQixPQUFPZCxJQUFJLENBQUNjLFlBQVk7SUFDNUI7SUFFQSxNQUFNSCxXQUFXckUsS0FBSzJFLElBQUksQ0FBQ0g7SUFDM0IsTUFBTUYsV0FBV3RFLEtBQUtDLEtBQUssQ0FBQ3VFO0lBRTVCLElBQUlJLFNBQVM7SUFDYixJQUFJQyxTQUFTO0lBRWIsSUFBSUwsY0FBY0gsYUFBYSxNQUFNO1FBQ2pDTyxTQUFTO0lBQ2IsT0FDSyxJQUFJSixjQUFjSCxhQUFhLE1BQU07UUFDdENRLFNBQVM7SUFDYjtJQUNBLDZDQUE2QztJQUN6Qyx3QkFBd0I7SUFFNUIsT0FBUSxDQUFDbkIsSUFBSSxDQUFDVyxTQUFTLEdBQUdPLFNBQVNsQixJQUFJLENBQUNZLFNBQVMsR0FBR08sTUFBSyxJQUFNRCxDQUFBQSxTQUFTQyxNQUFLO0FBQ2pGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvRGF0YS9CYW5rLnRzPzY3MmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RhcnQgfSBmcm9tIFwicmVwbFwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJQWNjb3VudExpbmUge1xyXG4gICAgZGF0ZTogRGF0ZTtcclxuICAgIHBjdEluTW9udGg6IG51bWJlcjsgLy8gbWFwIDEtMjgvMjkvMzAvMzEgbW9udGggdG8gMS0xMDAlXHJcbiAgICBkZWJpdDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgY3JlZGl0OiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBsYWJlbDogc3RyaW5nO1xyXG4gICAgYmFsYW5jZTogbnVtYmVyO1xyXG4gICAgdGFnczogc3RyaW5nW107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFjY291bnRMaW5lcyB7XHJcbiAgICBsaW5lczogSUFjY291bnRMaW5lW107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFjY291bnRQZXJpb2Qge1xyXG4gICAgYmVnaW46IERhdGU7XHJcbiAgICBlbmQ6IERhdGU7XHJcbiAgICBsaW5lczogSUFjY291bnRMaW5lW107XHJcbiAgICBpc0FnZ3JlZ2F0ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFRNYXBwaW5nID0ge1ttYXRjaDogc3RyaW5nXTogc3RyaW5nfVxyXG5leHBvcnQgaW50ZXJmYWNlIElNYXBwaW5nTGluZSB7XHJcbiAgICBtYXRjaDogc3RyaW5nO1xyXG4gICAgdGFnczogc3RyaW5nO1xyXG59XHJcbmV4cG9ydCB0eXBlIFRhZ0xpbmUgPSB7W2lkOiBzdHJpbmddOiB7Y3JlZGl0OiBudW1iZXIsIGRlYml0OiBudW1iZXIsIHN1YlRhZ3M6IFRhZ0xpbmV9OyB9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElUYWcge1xyXG4gICAgdGFnOiBzdHJpbmc7XHJcbiAgICBjb3VudDogbnVtYmVyO1xyXG4gICAgZnJlcXVlbmN5OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFRCdWRnZXQgPSB7W3RhZzogc3RyaW5nXTogbnVtYmVyfVxyXG5leHBvcnQgaW50ZXJmYWNlIElUYWdCdWRnZXQge1xyXG4gICAgdGFnOiBzdHJpbmc7XHJcbiAgICBhbGxvd2VkOiBudW1iZXI7XHJcbiAgICBjb25zdW1lZDogbnVtYmVyO1xyXG4gICAgbGluZXM6IElBY2NvdW50TGluZVtdO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElCdWRnZXRMaW5lIHtcclxuICAgIHRhZzogc3RyaW5nO1xyXG4gICAgYW1vdW50OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIEVEb2N1bWVudFR5cGUge1xyXG4gICAgQUNDT1VOVCA9IFwiQUNDT1VOVFwiLFxyXG4gICAgTUFQUElORyA9IFwiTUFQUElOR1wiLFxyXG4gICAgQlVER0VUICA9IFwiQlVER0VUXCIsXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZ2dyZWdhdGVCeVRhZ3MobGluZXM6IElBY2NvdW50TGluZVtdLCB0YWdMZXZlbDogbnVtYmVyLCBleGNsdWRlVGFnOiBzdHJpbmcpOiBUYWdMaW5lIHtcclxuICAgIGxldCBhZ3JlZ2F0ZTogVGFnTGluZSA9IHt9O1xyXG4gICAgbGV0IGlzUmVjdXJzaXZlID0gdGFnTGV2ZWwgPCAwO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XHJcblxyXG4gICAgICAgIGxldCBpZHggPSBleGNsdWRlVGFnID09PSBcIlwiID8gMCA6IGxpbmUudGFncy5pbmRleE9mKGV4Y2x1ZGVUYWcpO1xyXG4gICAgICAgIGxldCBsZXZlbCA9IGlzUmVjdXJzaXZlID8gKGlkeCAlIGxpbmUudGFncy5sZW5ndGgpIDogdGFnTGV2ZWw7XHJcbiAgICAgICAgbGV0IHRhZyA9IGxpbmUudGFnc1tsZXZlbF07XHJcblxyXG4gICAgICAgIGlmICh0YWcgPT09IGV4Y2x1ZGVUYWcgJiYgbGV2ZWwgPCAobGluZS50YWdzLmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgIHRhZyA9IGxpbmUudGFnc1tsZXZlbCArIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YWcgPT09IGV4Y2x1ZGVUYWcgJiYgbGV2ZWwgPT09IChsaW5lLnRhZ3MubGVuZ3RoIC0gMSkpIHtcclxuICAgICAgICAgICAgdGFnID0gaXNSZWN1cnNpdmUgPyBsaW5lLnRhZ3NbMF0gOiBcIlVuZGVmaW5lZFwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRhZyBpbiBhZ3JlZ2F0ZSkge1xyXG4gICAgICAgICAgICBhZ3JlZ2F0ZVt0YWddLmNyZWRpdCArPSBsaW5lLmNyZWRpdCA/PyAwO1xyXG4gICAgICAgICAgICBhZ3JlZ2F0ZVt0YWddLmRlYml0ICs9IGxpbmUuZGViaXQgPz8gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFncmVnYXRlW3RhZ10gPSB7XHJcbiAgICAgICAgICAgICAgICBjcmVkaXQ6IGxpbmUuY3JlZGl0ID8/IDAsXHJcbiAgICAgICAgICAgICAgICBkZWJpdDogbGluZS5kZWJpdCA/PyAwLFxyXG4gICAgICAgICAgICAgICAgc3ViVGFnczoge31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYWdyZWdhdGU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VGFncyhsaW5lczogSUFjY291bnRMaW5lW10pOiBzdHJpbmdbXSB7XHJcbiAgICBsZXQgdGFnczogc3RyaW5nW10gPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0YWdzLnB1c2goLi4ubGluZXNbaV0udGFncyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcclxuICAgIHRhZ3MgPSB0YWdzLmZpbHRlcihmdW5jdGlvbih0YWcsIGlkeCkge1xyXG4gICAgICAgIHJldHVybiB0YWdzLmluZGV4T2YodGFnKSA9PT0gaWR4O1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRhZ3Muc29ydCgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFRhZ3NXaXRoQ291bnQobGluZXM6IElBY2NvdW50TGluZVtdLCBzdGFydGluZ1RhZzogc3RyaW5nIHwgdW5kZWZpbmVkKTogSVRhZ1tdIHtcclxuICAgIGxldCB0YWdzOiBJVGFnW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0SWR4ID0gMDtcclxuICAgICAgICBsZXQgZW5kSWR4ID0gbGluZXNbaV0udGFncy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChzdGFydGluZ1RhZykge1xyXG4gICAgICAgICAgICAvLyBDb25zaWRlciBvbmx5IHRoZSBuZXh0IGFmdGVyIHRoZSBzdGFydGluZ1RhZ1xyXG4gICAgICAgICAgICBjb25zdCBpZHggPSBsaW5lc1tpXS50YWdzLmZpbmRJbmRleCgodGFnKSA9PiB0YWcgPT09IHN0YXJ0aW5nVGFnKTtcclxuICAgICAgICAgICAgaWYgKGlkeCA9PT0gKGxpbmVzW2ldLnRhZ3MubGVuZ3RoIC0gMSkpIHtcclxuICAgICAgICAgICAgICAgIC8vSWdub3JlXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHN0YXJ0aW5nVGFnIGlzIHRoZSBsYXN0IG9uZSBpbiB0aGUgdGFnIGxpc3QsIGNvbnNpZGVyIHRoZSBmaXJzdCB0YWcgb2YgdGhlIGxpc3QgaW5zdGVhZFxyXG4gICAgICAgICAgICAgICAgLy9zdGFydElkeCA9IDA7XHJcbiAgICAgICAgICAgICAgICAvL2VuZElkeCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN0YXJ0SWR4ID0gaWR4ICsgMTtcclxuICAgICAgICAgICAgZW5kSWR4ID0gaWR4ICsgMjtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJzdGFydGluZyB0YWcgaWR4IFwiICsgc3RhcnRJZHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0SWR4OyBqIDwgZW5kSWR4OyBqKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdGFnSWR4ID0gdGFncy5maW5kSW5kZXgoKHRhZykgPT4gdGFnLnRhZyA9PT0gbGluZXNbaV0udGFnc1tqXSk7XHJcbiAgICAgICAgICAgIGlmICh0YWdJZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0YWdzLnB1c2goe3RhZzogbGluZXNbaV0udGFnc1tqXSwgY291bnQ6IDEsIGZyZXF1ZW5jeTogMS9saW5lcy5sZW5ndGh9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRhZ3NbdGFnSWR4XS5jb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgdGFnc1t0YWdJZHhdLmZyZXF1ZW5jeSA9IHRhZ3NbdGFnSWR4XS5jb3VudC9saW5lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhZ3Muc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZyZXFBID0gTWF0aC5mbG9vcihhLmZyZXF1ZW5jeSAqIDEwMCk7XHJcbiAgICAgICAgY29uc3QgZnJlcUIgPSBNYXRoLmZsb29yKGIuZnJlcXVlbmN5ICogMTAwKTtcclxuICAgICAgICBpZiAoZnJlcUEgPT09IGZyZXFCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnRhZyA+IGIudGFnID8gMSA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKE1hdGguZmxvb3IoYi5mcmVxdWVuY3kgKiAxMDApIC0gTWF0aC5mbG9vcihhLmZyZXF1ZW5jeSAqIDEwMCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0TWFpblRhZ3NXaXRoQ291bnQobGluZXM6IElBY2NvdW50TGluZVtdKTogSVRhZ1tdIHtcclxuICAgIGxldCB0YWdzOiBJVGFnW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0SWR4ID0gMDtcclxuICAgICAgICBsZXQgZW5kSWR4ID0gMDtcclxuXHJcbiAgICAgICAgY29uc3QgdGFnSWR4ID0gdGFncy5maW5kSW5kZXgoKHRhZykgPT4gdGFnLnRhZyA9PT0gbGluZXNbaV0udGFnc1tqXSk7XHJcbiAgICAgICAgICAgIGlmICh0YWdJZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0YWdzLnB1c2goe3RhZzogbGluZXNbaV0udGFnc1tqXSwgY291bnQ6IDEsIGZyZXF1ZW5jeTogMS9saW5lcy5sZW5ndGh9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRhZ3NbdGFnSWR4XS5jb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgdGFnc1t0YWdJZHhdLmZyZXF1ZW5jeSA9IHRhZ3NbdGFnSWR4XS5jb3VudC9saW5lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFncy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZnJlcUEgPSBNYXRoLmZsb29yKGEuZnJlcXVlbmN5ICogMTAwKTtcclxuICAgICAgICBjb25zdCBmcmVxQiA9IE1hdGguZmxvb3IoYi5mcmVxdWVuY3kgKiAxMDApO1xyXG4gICAgICAgIGlmIChmcmVxQSA9PT0gZnJlcUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEudGFnID4gYi50YWcgPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoTWF0aC5mbG9vcihiLmZyZXF1ZW5jeSAqIDEwMCkgLSBNYXRoLmZsb29yKGEuZnJlcXVlbmN5ICogMTAwKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFnZ3JlZ2F0ZUJ5VGFnKGxpbmVzOiBJQWNjb3VudExpbmVbXSwgdGFnOiBzdHJpbmcpOiBUYWdMaW5lIHtcclxuICAgIGxldCBhZ3JlZ2F0ZTogVGFnTGluZSA9IHt9O1xyXG4gICAgY29uc3QgdGFnZ2VkTGluZXMgPSB0YWcgPT09IFwiXCIgPyBsaW5lcyA6IGxpbmVzLmZpbHRlcigobGluZSkgPT4gbGluZS50YWdzLmluZGV4T2YodGFnKSAhPT0gLTEpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFnZ2VkTGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBsaW5lID0gdGFnZ2VkTGluZXNbaV07XHJcbiAgICAgICAgaWYgKHRhZyBpbiBhZ3JlZ2F0ZSkge1xyXG4gICAgICAgICAgICBhZ3JlZ2F0ZVt0YWddLmNyZWRpdCArPSBsaW5lLmNyZWRpdCA/PyAwO1xyXG4gICAgICAgICAgICBhZ3JlZ2F0ZVt0YWddLmRlYml0ICs9IGxpbmUuZGViaXQgPz8gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFncmVnYXRlW3RhZ10gPSB7XHJcbiAgICAgICAgICAgICAgICBjcmVkaXQ6IGxpbmUuY3JlZGl0ID8/IDAsXHJcbiAgICAgICAgICAgICAgICBkZWJpdDogbGluZS5kZWJpdCA/PyAwLFxyXG4gICAgICAgICAgICAgICAgc3ViVGFnczoge31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFncmVnYXRlW3RhZ10uc3ViVGFncyA9IGFnZ3JlZ2F0ZUJ5VGFncyh0YWdnZWRMaW5lcywgMCwgdGFnKTtcclxuICAgIHJldHVybiBhZ3JlZ2F0ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFnZ3JlZ2F0ZUJ5RGF0ZShsaW5lczogSUFjY291bnRMaW5lW10sIG1vbnRobHk6IGJvb2xlYW4gPSBmYWxzZSk6IFRhZ0xpbmUge1xyXG4gICAgbGV0IGFncmVnYXRlOiBUYWdMaW5lID0ge307XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcclxuICAgICAgICBsZXQgc3RyRGF0ZSA9IGxpbmUuZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoXCJmci1GUlwiKTtcclxuICAgICAgICBpZiAobW9udGhseSkge1xyXG4gICAgICAgICAgICBzdHJEYXRlID0gc3RyRGF0ZS5zbGljZShzdHJEYXRlLmluZGV4T2YoXCIvXCIpKzEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3RyRGF0ZSBpbiBhZ3JlZ2F0ZSkge1xyXG4gICAgICAgICAgICBhZ3JlZ2F0ZVtzdHJEYXRlXS5jcmVkaXQgKz0gbGluZS5jcmVkaXQgPz8gMDtcclxuICAgICAgICAgICAgYWdyZWdhdGVbc3RyRGF0ZV0uZGViaXQgKz0gbGluZS5kZWJpdCA/PyAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWdyZWdhdGVbc3RyRGF0ZV0gPSB7XHJcbiAgICAgICAgICAgICAgICBjcmVkaXQ6IGxpbmUuY3JlZGl0ID8/IDAsXHJcbiAgICAgICAgICAgICAgICBkZWJpdDogbGluZS5kZWJpdCA/PyAwLFxyXG4gICAgICAgICAgICAgICAgc3ViVGFnczoge31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhZ3JlZ2F0ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjY291bnRQZXJpb2RTdHIoYWNjb3VudDogSUFjY291bnRQZXJpb2QpOiBzdHJpbmcge1xyXG4gICAgbGV0IGFnZ3JlZ2F0ZWRNZW50aW9uID0gYWNjb3VudC5pc0FnZ3JlZ2F0ZWQgPyBcIiAoQWdncmVnYXRlZCkgXCIgOiBcIlwiO1xyXG4gICAgcmV0dXJuIGFjY291bnQuYmVnaW4udG9Mb2NhbGVEYXRlU3RyaW5nKCkgKyBcIiAtIFwiICsgYWNjb3VudC5lbmQudG9Mb2NhbGVEYXRlU3RyaW5nKCkgKyBhZ2dyZWdhdGVkTWVudGlvbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFdob2xlUGVyaW9kKGFjY291bnRzOiBJQWNjb3VudFBlcmlvZFtdKTogSUFjY291bnRQZXJpb2Qge1xyXG4gICAgY29uc3Qgd2hvbGVQZXJpb2Q6IElBY2NvdW50UGVyaW9kID0gYWNjb3VudHMucmVkdWNlKChyZXN1bHQsIHBlcmlvZCkgPT4ge1xyXG4gICAgICAgIHJldHVybiB7Li4ucmVzdWx0LFxyXG4gICAgICAgICAgICBiZWdpbjogcGVyaW9kLmJlZ2luIDwgcmVzdWx0LmJlZ2luID8gcGVyaW9kLmJlZ2luIDogcmVzdWx0LmJlZ2luLFxyXG4gICAgICAgICAgICBlbmQ6IHBlcmlvZC5iZWdpbiA+IHJlc3VsdC5iZWdpbiA/IHBlcmlvZC5iZWdpbiA6IHJlc3VsdC5iZWdpbixcclxuICAgICAgICAgICAgbGluZXM6IFsuLi5yZXN1bHQubGluZXMsIC4uLnBlcmlvZC5saW5lc10sXHJcbiAgICAgICAgICAgIGlzQWdncmVnYXRlZDogdHJ1ZX1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICB3aG9sZVBlcmlvZC5saW5lcy5zb3J0KChhOiBJQWNjb3VudExpbmUsIGI6IElBY2NvdW50TGluZSkgPT4ge3JldHVybiBhLmRhdGUuZ2V0VGltZSgpID09PSBiLmRhdGUuZ2V0VGltZSgpID8gMCA6IChhLmRhdGUuZ2V0VGltZSgpID4gYi5kYXRlLmdldFRpbWUoKSA/IDEgOiAtMSk7fSk7XHJcbiAgICByZXR1cm4gd2hvbGVQZXJpb2Q7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1BheW1lbnRMYWJlbChsYWJlbDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKC8oUEFJRU1FTlRcXHMpLyk7XHJcbiAgICBjb25zdCB0ZXN0ID0gcmVnRXhwLnRlc3QobGFiZWwudG9VcHBlckNhc2UoKSk7XHJcbiAgICByZXR1cm4gdGVzdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRGlyZWN0RGViaXRMYWJlbChsYWJlbDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKC8oUFJMVlxcc1NFUEFcXHMpLyk7XHJcbiAgICBjb25zdCB0ZXN0ID0gcmVnRXhwLnRlc3QobGFiZWwudG9VcHBlckNhc2UoKSk7XHJcbiAgICByZXR1cm4gdGVzdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQmFua1RyYW5zZmVyTGFiZWwobGFiZWw6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cCgvKFZJUlxccykvKTtcclxuICAgIGNvbnN0IHRlc3QgPSByZWdFeHAudGVzdChsYWJlbC50b1VwcGVyQ2FzZSgpKTtcclxuICAgIHJldHVybiB0ZXN0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNXaXRoZHJhd2FsTGFiZWwobGFiZWw6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cCgvKFJFVFJBSVRcXHNEQUJcXHMpLyk7XHJcbiAgICBjb25zdCB0ZXN0ID0gcmVnRXhwLnRlc3QobGFiZWwudG9VcHBlckNhc2UoKSk7XHJcbiAgICByZXR1cm4gdGVzdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBheW1lbnRJZChsYWJlbDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIC8vUEFJRU1FTlQgQ0IgMzAwNyBGUiBMWU9OIExBLUJBUkdFIENBUlRFIDIxNzhcclxuICAgIGNvbnN0IG1hdGNoZXMgPSBsYWJlbC50b1VwcGVyQ2FzZSgpLm1hdGNoKC8oPzpQQUlFTUVOVFxccyg/OkNCfFBTQylcXHNcXGRcXGRcXGRcXGRcXHMpKChbYS16QS1aXXwtfF98XFxkK3xcXC98XFwqfFxccykrKSg/OkNBUlRFXFxzXFxkXFxkXFxkXFxkKS8pO1xyXG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzFdIDogXCJcIjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERpcmVjdERlYml0SWQobGFiZWw6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBtYXRjaGVzID0gbGFiZWwudG9VcHBlckNhc2UoKS5tYXRjaCgvKD86UFJMVlxcc1NFUEFcXHMpKChbYS16QS1aXXwtfF98XFxzKSspLyk7XHJcbiAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiBcIlwiO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFua1RyYW5zZmVySWQobGFiZWw6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBtYXRjaGVzID0gbGFiZWwudG9VcHBlckNhc2UoKS5tYXRjaCgvKD86VklSXFxzKSgoW2EtekEtWl18LXxffFxccykrKS8pO1xyXG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzFdIDogXCJcIjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFdpdGhkcmF3YWxJZChsYWJlbDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IG1hdGNoZXMgPSBsYWJlbC50b1VwcGVyQ2FzZSgpLm1hdGNoKC9SRVRSQUlUIERBQi8pO1xyXG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogXCJcIjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RJZEZyb21MYWJlbChsYWJlbDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGlmIChpc0JhbmtUcmFuc2ZlckxhYmVsKGxhYmVsKSkge1xyXG4gICAgICAgIHJldHVybiBnZXRCYW5rVHJhbnNmZXJJZChsYWJlbCkudHJpbSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc1BheW1lbnRMYWJlbChsYWJlbCkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0UGF5bWVudElkKGxhYmVsKS50cmltKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzRGlyZWN0RGViaXRMYWJlbChsYWJlbCkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGlyZWN0RGViaXRJZChsYWJlbCkudHJpbSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc1dpdGhkcmF3YWxMYWJlbChsYWJlbCkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0V2l0aGRyYXdhbElkKGxhYmVsKS50cmltKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxhYmVsLnRyaW0oKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRhZ1BlcmlvZHMocGVyaW9kczogSUFjY291bnRQZXJpb2RbXSwgbWFwcGluZzogVE1hcHBpbmcpOiBJQWNjb3VudFBlcmlvZFtdIHtcclxuICAgIGNvbnN0IHRhZ2dlZFBlcmlvZHMgPSBbLi4ucGVyaW9kc107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhZ2dlZFBlcmlvZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwZXJpb2QgPSB0YWdnZWRQZXJpb2RzW2ldO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGVyaW9kLmxpbmVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBwZXJpb2QubGluZXNbal07XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZXh0cmFjdElkRnJvbUxhYmVsKGxpbmUubGFiZWwpO1xyXG4gICAgICAgICAgICBpZiAobWFwcGluZ1tpZF0pIHtcclxuICAgICAgICAgICAgICAgIGxpbmUudGFncyA9IG1hcHBpbmdbaWRdLnNwbGl0KCc+Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFnZ2VkUGVyaW9kcztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJQm94UGxvdCB7XHJcbiAgICBwY3RJbk1vbnRoOiBudW1iZXI7XHJcbiAgICBtaW5pbXVtOiBudW1iZXI7XHJcbiAgICBmaXJzdFF1YXJ0aWxlOiBudW1iZXI7XHJcbiAgICBtZWFuOiBudW1iZXI7XHJcbiAgICBtZWRpYW5lOiBudW1iZXI7XHJcbiAgICB0aGlyZFF1YXJ0aWxlOiBudW1iZXI7XHJcbiAgICBtYXhpbXVtOiBudW1iZXJcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJveFBsb3RzRnJvbUxpbmVzKGFsbEFjY291bnRMaW5lczogSUFjY291bnRMaW5lW10pOiBJQm94UGxvdFtdIHtcclxuICAgIGNvbnN0IHN0ZXAgPSAxMDtcclxuICAgIGNvbnN0IGJveFBsb3RCeVN0ZXA6IElCb3hQbG90W10gPSBbXTtcclxuXHJcbiAgICBsZXQgdmFsdWVzID0gYWxsQWNjb3VudExpbmVzLmZpbHRlcigobGluZSkgPT4gbGluZS5wY3RJbk1vbnRoIDwgNSkubWFwKChsaW5lKSA9PiBsaW5lLmJhbGFuY2UpLnNvcnQoKGEsYikgPT4gYS1iKTtcclxuICAgIGxldCBib3hQbG90ID0gZXh0cmFjdEJveFBsb3RGcm9tRGF0YSh2YWx1ZXMpO1xyXG4gICAgYm94UGxvdC5wY3RJbk1vbnRoID0gMTtcclxuICAgIGJveFBsb3RCeVN0ZXAucHVzaChib3hQbG90KTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gNTsgaSA8PSA5NTsgaSs9c3RlcCkge1xyXG4gICAgICAgIGxldCB2YWx1ZXMgPSBhbGxBY2NvdW50TGluZXMuZmlsdGVyKChsaW5lKSA9PiBsaW5lLnBjdEluTW9udGggPj0gKGktNSkgJiYgbGluZS5wY3RJbk1vbnRoIDwgKGkrNSkpLm1hcCgobGluZSkgPT4gbGluZS5iYWxhbmNlKS5zb3J0KChhLGIpID0+IGEtYik7XHJcbiAgICAgICAgY29uc3QgYm94UGxvdCA9IGV4dHJhY3RCb3hQbG90RnJvbURhdGEodmFsdWVzKTtcclxuICAgICAgICBib3hQbG90LnBjdEluTW9udGggPSBpO1xyXG4gICAgICAgIGJveFBsb3RCeVN0ZXAucHVzaChib3hQbG90KTtcclxuICAgIH1cclxuXHJcbiAgICB2YWx1ZXMgPSBhbGxBY2NvdW50TGluZXMuZmlsdGVyKChsaW5lKSA9PiBsaW5lLnBjdEluTW9udGggPj0gOTUpLm1hcCgobGluZSkgPT4gbGluZS5iYWxhbmNlKS5zb3J0KChhLGIpID0+IGEtYik7XHJcbiAgICBib3hQbG90ID0gZXh0cmFjdEJveFBsb3RGcm9tRGF0YSh2YWx1ZXMpO1xyXG4gICAgYm94UGxvdC5wY3RJbk1vbnRoID0gMTAwO1xyXG4gICAgYm94UGxvdEJ5U3RlcC5wdXNoKGJveFBsb3QpO1xyXG5cclxuICAgIHJldHVybiBib3hQbG90QnlTdGVwO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEJveFBsb3RGcm9tRGF0YShkYXRhOiBudW1iZXJbXSk6IElCb3hQbG90IHtcclxuXHJcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwY3RJbk1vbnRoOiBOYU4sXHJcbiAgICAgICAgICAgIGZpcnN0UXVhcnRpbGU6IE5hTixcclxuICAgICAgICAgICAgdGhpcmRRdWFydGlsZTogTmFOLFxyXG4gICAgICAgICAgICBtZWRpYW5lOiBOYU4sXHJcbiAgICAgICAgICAgIG1lYW46IE5hTixcclxuICAgICAgICAgICAgbWluaW11bTogTmFOLFxyXG4gICAgICAgICAgICBtYXhpbXVtOiBOYU5cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGZpcnN0UXVhcnRpbGVJZHggPSBNYXRoLm1heCgwLCAoKGRhdGEubGVuZ3RoICsgMykgLyA0KSAtMSk7XHJcbiAgICBjb25zdCB0aGlyZFF1YXJ0aWxlSWR4ID0gTWF0aC5tYXgoMCwgKCgzICogZGF0YS5sZW5ndGggKyAxKSAvIDQpIC0xKTtcclxuXHJcbiAgICBsZXQgbWVkaWFuZTogbnVtYmVyO1xyXG4gICAgaWYgKGRhdGEubGVuZ3RoICUgMiA9PT0gMCAmJiBkYXRhLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICBjb25zdCBsb3dlcklkeCA9ICgoZGF0YS5sZW5ndGgpIC8gMikgLSAyO1xyXG4gICAgICAgIGNvbnN0IHVwcGVySWR4ID0gKChkYXRhLmxlbmd0aCkgLyAyKSAtIDE7XHJcbiAgICAgICAgbWVkaWFuZSA9IChkYXRhW2xvd2VySWR4XSArIGRhdGFbdXBwZXJJZHhdKSAvIDI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgIGNvbnN0IGlkeCA9IE1hdGgubWF4KDAsICgoZGF0YS5sZW5ndGggKyAxKSAvIDIpIC0xKTtcclxuICAgICAgIG1lZGlhbmUgPSBkYXRhW2lkeF07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG1lYW46IG51bWJlciA9IDA7XHJcbiAgICBtZWFuID0gZGF0YS5yZWR1Y2UoKGEsIGIpID0+IGEgK2IpO1xyXG4gICAgbWVhbiA9IG1lYW4gLyBkYXRhLmxlbmd0aDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHBjdEluTW9udGg6IE5hTixcclxuICAgICAgICBmaXJzdFF1YXJ0aWxlOiBjb21wdXRlUXVhcnRpbGVWYWx1ZShmaXJzdFF1YXJ0aWxlSWR4LCBkYXRhKSxcclxuICAgICAgICB0aGlyZFF1YXJ0aWxlOiBjb21wdXRlUXVhcnRpbGVWYWx1ZSh0aGlyZFF1YXJ0aWxlSWR4LCBkYXRhKSxcclxuICAgICAgICBtZWRpYW5lOiBtZWRpYW5lLFxyXG4gICAgICAgIG1lYW46IG1lYW4sXHJcbiAgICAgICAgbWluaW11bTogZGF0YVswXSxcclxuICAgICAgICBtYXhpbXVtOiBkYXRhW2RhdGEubGVuZ3RoIC0gMV1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUXVhcnRpbGVWYWx1ZShxdWFydGlsZUlkeDogbnVtYmVyLCBkYXRhOiBudW1iZXJbXSk6IG51bWJlciB7XHJcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihxdWFydGlsZUlkeCkpIHtcclxuICAgICAgICByZXR1cm4gZGF0YVtxdWFydGlsZUlkeF07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbG93ZXJJZHggPSBNYXRoLmNlaWwocXVhcnRpbGVJZHgpO1xyXG4gICAgY29uc3QgdXBwZXJJZHggPSBNYXRoLmZsb29yKHF1YXJ0aWxlSWR4KTtcclxuXHJcbiAgICBsZXQgY29lZmYxID0gMTtcclxuICAgIGxldCBjb2VmZjIgPSAxO1xyXG5cclxuICAgIGlmIChxdWFydGlsZUlkeCAtIGxvd2VySWR4ID09PSAwLjI1KSB7XHJcbiAgICAgICAgY29lZmYxID0gMztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHF1YXJ0aWxlSWR4IC0gbG93ZXJJZHggPT09IDAuNzUpIHtcclxuICAgICAgICBjb2VmZjIgPSAzO1xyXG4gICAgfVxyXG4gICAgLy8gZWxzZSB7ICAocXVhcnRpbGVJZHggLSBsb3dlcklkeCA9PT0gMC41KSB7XHJcbiAgICAgICAgLy9jb2VmZjEgPSAxLCBjb2VmZjIgPSAxXHJcblxyXG4gICAgcmV0dXJuICAoZGF0YVtsb3dlcklkeF0gKiBjb2VmZjEgKyBkYXRhW3VwcGVySWR4XSAqIGNvZWZmMikgLyAoY29lZmYxICsgY29lZmYyKTtcclxufSJdLCJuYW1lcyI6WyJFRG9jdW1lbnRUeXBlIiwiYWdncmVnYXRlQnlUYWdzIiwibGluZXMiLCJ0YWdMZXZlbCIsImV4Y2x1ZGVUYWciLCJhZ3JlZ2F0ZSIsImlzUmVjdXJzaXZlIiwiaSIsImxlbmd0aCIsImxpbmUiLCJpZHgiLCJ0YWdzIiwiaW5kZXhPZiIsImxldmVsIiwidGFnIiwiY3JlZGl0IiwiZGViaXQiLCJzdWJUYWdzIiwiZXh0cmFjdFRhZ3MiLCJwdXNoIiwiZmlsdGVyIiwic29ydCIsImV4dHJhY3RUYWdzV2l0aENvdW50Iiwic3RhcnRpbmdUYWciLCJzdGFydElkeCIsImVuZElkeCIsImZpbmRJbmRleCIsImNvbnNvbGUiLCJsb2ciLCJqIiwidGFnSWR4IiwiY291bnQiLCJmcmVxdWVuY3kiLCJhIiwiYiIsImZyZXFBIiwiTWF0aCIsImZsb29yIiwiZnJlcUIiLCJleHRyYWN0TWFpblRhZ3NXaXRoQ291bnQiLCJhZ2dyZWdhdGVCeVRhZyIsInRhZ2dlZExpbmVzIiwiYWdncmVnYXRlQnlEYXRlIiwibW9udGhseSIsInN0ckRhdGUiLCJkYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwic2xpY2UiLCJnZXRBY2NvdW50UGVyaW9kU3RyIiwiYWNjb3VudCIsImFnZ3JlZ2F0ZWRNZW50aW9uIiwiaXNBZ2dyZWdhdGVkIiwiYmVnaW4iLCJlbmQiLCJnZXRXaG9sZVBlcmlvZCIsImFjY291bnRzIiwid2hvbGVQZXJpb2QiLCJyZWR1Y2UiLCJyZXN1bHQiLCJwZXJpb2QiLCJnZXRUaW1lIiwiaXNQYXltZW50TGFiZWwiLCJsYWJlbCIsInJlZ0V4cCIsIlJlZ0V4cCIsInRlc3QiLCJ0b1VwcGVyQ2FzZSIsImlzRGlyZWN0RGViaXRMYWJlbCIsImlzQmFua1RyYW5zZmVyTGFiZWwiLCJpc1dpdGhkcmF3YWxMYWJlbCIsImdldFBheW1lbnRJZCIsIm1hdGNoZXMiLCJtYXRjaCIsImdldERpcmVjdERlYml0SWQiLCJnZXRCYW5rVHJhbnNmZXJJZCIsImdldFdpdGhkcmF3YWxJZCIsImV4dHJhY3RJZEZyb21MYWJlbCIsInRyaW0iLCJ0YWdQZXJpb2RzIiwicGVyaW9kcyIsIm1hcHBpbmciLCJ0YWdnZWRQZXJpb2RzIiwiaWQiLCJzcGxpdCIsImdldEJveFBsb3RzRnJvbUxpbmVzIiwiYWxsQWNjb3VudExpbmVzIiwic3RlcCIsImJveFBsb3RCeVN0ZXAiLCJ2YWx1ZXMiLCJwY3RJbk1vbnRoIiwibWFwIiwiYmFsYW5jZSIsImJveFBsb3QiLCJleHRyYWN0Qm94UGxvdEZyb21EYXRhIiwiZGF0YSIsIk5hTiIsImZpcnN0UXVhcnRpbGUiLCJ0aGlyZFF1YXJ0aWxlIiwibWVkaWFuZSIsIm1lYW4iLCJtaW5pbXVtIiwibWF4aW11bSIsImZpcnN0UXVhcnRpbGVJZHgiLCJtYXgiLCJ0aGlyZFF1YXJ0aWxlSWR4IiwibG93ZXJJZHgiLCJ1cHBlcklkeCIsImNvbXB1dGVRdWFydGlsZVZhbHVlIiwicXVhcnRpbGVJZHgiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJjZWlsIiwiY29lZmYxIiwiY29lZmYyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Data/Bank.ts\n"));

/***/ })

});