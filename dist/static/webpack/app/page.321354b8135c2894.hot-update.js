"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Data/Bank.ts":
/*!*********************************!*\
  !*** ./components/Data/Bank.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EDocumentType: function() { return /* binding */ EDocumentType; },\n/* harmony export */   aggregateByDate: function() { return /* binding */ aggregateByDate; },\n/* harmony export */   aggregateByTag: function() { return /* binding */ aggregateByTag; },\n/* harmony export */   aggregateByTags: function() { return /* binding */ aggregateByTags; },\n/* harmony export */   extractIdFromLabel: function() { return /* binding */ extractIdFromLabel; },\n/* harmony export */   extractTags: function() { return /* binding */ extractTags; },\n/* harmony export */   extractTagsWithCount: function() { return /* binding */ extractTagsWithCount; },\n/* harmony export */   getAccountPeriodStr: function() { return /* binding */ getAccountPeriodStr; },\n/* harmony export */   getBankTransferId: function() { return /* binding */ getBankTransferId; },\n/* harmony export */   getDirectDebitId: function() { return /* binding */ getDirectDebitId; },\n/* harmony export */   getPaymentId: function() { return /* binding */ getPaymentId; },\n/* harmony export */   getWholePeriod: function() { return /* binding */ getWholePeriod; },\n/* harmony export */   getWithdrawalId: function() { return /* binding */ getWithdrawalId; },\n/* harmony export */   isBankTransferLabel: function() { return /* binding */ isBankTransferLabel; },\n/* harmony export */   isDirectDebitLabel: function() { return /* binding */ isDirectDebitLabel; },\n/* harmony export */   isPaymentLabel: function() { return /* binding */ isPaymentLabel; },\n/* harmony export */   isWithdrawalLabel: function() { return /* binding */ isWithdrawalLabel; },\n/* harmony export */   tagPeriods: function() { return /* binding */ tagPeriods; }\n/* harmony export */ });\nvar EDocumentType;\n(function(EDocumentType) {\n    EDocumentType[EDocumentType[\"ACCOUNT\"] = 0] = \"ACCOUNT\";\n    EDocumentType[EDocumentType[\"ACCOUNT\"] = 1] = \"ACCOUNT\";\n})(EDocumentType || (EDocumentType = {}));\nfunction aggregateByTags(lines, tagLevel, excludeTag) {\n    let agregate = {};\n    let isRecursive = tagLevel < 0;\n    for(let i = 0; i < lines.length; i++){\n        const line = lines[i];\n        let idx = excludeTag === \"\" ? 0 : line.tags.indexOf(excludeTag);\n        let level = isRecursive ? idx % line.tags.length : tagLevel;\n        let tag = line.tags[level];\n        if (tag === excludeTag && level < line.tags.length - 1) {\n            tag = line.tags[level + 1];\n        } else if (tag === excludeTag && level === line.tags.length - 1) {\n            tag = isRecursive ? line.tags[0] : \"Undefined\";\n        }\n        if (tag in agregate) {\n            var _line_credit;\n            agregate[tag].credit += (_line_credit = line.credit) !== null && _line_credit !== void 0 ? _line_credit : 0;\n            var _line_debit;\n            agregate[tag].debit += (_line_debit = line.debit) !== null && _line_debit !== void 0 ? _line_debit : 0;\n        } else {\n            var _line_credit1, _line_debit1;\n            agregate[tag] = {\n                credit: (_line_credit1 = line.credit) !== null && _line_credit1 !== void 0 ? _line_credit1 : 0,\n                debit: (_line_debit1 = line.debit) !== null && _line_debit1 !== void 0 ? _line_debit1 : 0,\n                subTags: {}\n            };\n        }\n    }\n    return agregate;\n}\nfunction extractTags(lines) {\n    let tags = [];\n    for(let i = 0; i < lines.length; i++){\n        tags.push(...lines[i].tags);\n    }\n    // Remove duplicates\n    tags = tags.filter(function(tag, idx) {\n        return tags.indexOf(tag) === idx;\n    });\n    return tags.sort();\n}\nfunction extractTagsWithCount(lines) {\n    let tags = [];\n    for(let i = 0; i < lines.length; i++){\n        for(let j = 0; j < lines[i].tags.length; j++){\n            const tagIdx = tags.findIndex((tag)=>tag.tag === lines[i].tags[j]);\n            if (tagIdx === -1) {\n                tags.push({\n                    tag: lines[i].tags[j],\n                    count: 1,\n                    frequency: 1 / lines.length\n                });\n            } else {\n                tags[tagIdx].count++;\n                tags[tagIdx].frequency = tags[tagIdx].count / lines.length;\n            }\n        }\n    }\n    return tags.sort((a, b)=>{\n        const freqA = Math.floor(a.frequency * 100);\n        const freqB = Math.floor(b.frequency * 100);\n        if (freqA === freqB) {\n            return a.tag > b.tag ? 1 : -1;\n        }\n        return Math.floor(b.frequency * 100) - Math.floor(a.frequency * 100);\n    });\n}\nfunction aggregateByTag(lines, tag) {\n    let agregate = {};\n    const taggedLines = tag === \"\" ? lines : lines.filter((line)=>line.tags.indexOf(tag) !== -1);\n    for(let i = 0; i < taggedLines.length; i++){\n        const line = taggedLines[i];\n        if (tag in agregate) {\n            var _line_credit;\n            agregate[tag].credit += (_line_credit = line.credit) !== null && _line_credit !== void 0 ? _line_credit : 0;\n            var _line_debit;\n            agregate[tag].debit += (_line_debit = line.debit) !== null && _line_debit !== void 0 ? _line_debit : 0;\n        } else {\n            var _line_credit1, _line_debit1;\n            agregate[tag] = {\n                credit: (_line_credit1 = line.credit) !== null && _line_credit1 !== void 0 ? _line_credit1 : 0,\n                debit: (_line_debit1 = line.debit) !== null && _line_debit1 !== void 0 ? _line_debit1 : 0,\n                subTags: {}\n            };\n        }\n    }\n    agregate[tag].subTags = aggregateByTags(taggedLines, 0, tag);\n    return agregate;\n}\nfunction aggregateByDate(lines) {\n    let monthly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    let agregate = {};\n    for(let i = 0; i < lines.length; i++){\n        const line = lines[i];\n        let strDate = line.date.toLocaleDateString(\"fr-FR\");\n        if (monthly) {\n            strDate = strDate.slice(strDate.indexOf(\"/\") + 1);\n        }\n        if (strDate in agregate) {\n            var _line_credit;\n            agregate[strDate].credit += (_line_credit = line.credit) !== null && _line_credit !== void 0 ? _line_credit : 0;\n            var _line_debit;\n            agregate[strDate].debit += (_line_debit = line.debit) !== null && _line_debit !== void 0 ? _line_debit : 0;\n        } else {\n            var _line_credit1, _line_debit1;\n            agregate[strDate] = {\n                credit: (_line_credit1 = line.credit) !== null && _line_credit1 !== void 0 ? _line_credit1 : 0,\n                debit: (_line_debit1 = line.debit) !== null && _line_debit1 !== void 0 ? _line_debit1 : 0,\n                subTags: {}\n            };\n        }\n    }\n    return agregate;\n}\nfunction getAccountPeriodStr(account) {\n    let aggregatedMention = account.isAggregated ? \" (Aggregated) \" : \"\";\n    return account.begin.toLocaleDateString() + \" - \" + account.end.toLocaleDateString() + aggregatedMention;\n}\nfunction getWholePeriod(accounts) {\n    const wholePeriod = accounts.reduce((result, period)=>{\n        return {\n            ...result,\n            begin: period.begin < result.begin ? period.begin : result.begin,\n            end: period.begin > result.begin ? period.begin : result.begin,\n            lines: [\n                ...result.lines,\n                ...period.lines\n            ],\n            isAggregated: true\n        };\n    });\n    wholePeriod.lines.sort((a, b)=>{\n        return a.date > b.date ? 1 : -1;\n    });\n    return wholePeriod;\n}\nfunction isPaymentLabel(label) {\n    const regExp = new RegExp(/(PAIEMENT\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction isDirectDebitLabel(label) {\n    const regExp = new RegExp(/(PRLV\\sSEPA\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction isBankTransferLabel(label) {\n    const regExp = new RegExp(/(VIR\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction isWithdrawalLabel(label) {\n    const regExp = new RegExp(/(RETRAIT\\sDAB\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction getPaymentId(label) {\n    //PAIEMENT CB 3007 FR LYON LA-BARGE CARTE 2178\n    const matches = label.toUpperCase().match(/(?:PAIEMENT\\s(?:CB|PSC)\\s\\d\\d\\d\\d\\s)(([a-zA-Z]|-|_|\\d+|\\/|\\*|\\s)+)(?:CARTE\\s\\d\\d\\d\\d)/);\n    return matches ? matches[1] : \"\";\n}\nfunction getDirectDebitId(label) {\n    const matches = label.toUpperCase().match(/(?:PRLV\\sSEPA\\s)(([a-zA-Z]|-|_|\\s)+)/);\n    return matches ? matches[1] : \"\";\n}\nfunction getBankTransferId(label) {\n    const matches = label.toUpperCase().match(/(?:VIR\\s)(([a-zA-Z]|-|_|\\s)+)/);\n    return matches ? matches[1] : \"\";\n}\nfunction getWithdrawalId(label) {\n    const matches = label.toUpperCase().match(/RETRAIT DAB/);\n    return matches ? matches[0] : \"\";\n}\nfunction extractIdFromLabel(label) {\n    if (isBankTransferLabel(label)) {\n        return getBankTransferId(label).trim();\n    }\n    if (isPaymentLabel(label)) {\n        return getPaymentId(label).trim();\n    }\n    if (isDirectDebitLabel(label)) {\n        return getDirectDebitId(label).trim();\n    }\n    if (isWithdrawalLabel(label)) {\n        return getWithdrawalId(label).trim();\n    }\n    return label.trim();\n}\nfunction tagPeriods(periods, mapping) {\n    const taggedPeriods = [\n        ...periods\n    ];\n    for(let i = 0; i < taggedPeriods.length; i++){\n        const period = taggedPeriods[i];\n        for(let j = 0; j < period.lines.length; j++){\n            const line = period.lines[j];\n            const id = extractIdFromLabel(line.label);\n            if (mapping[id]) {\n                line.tags = mapping[id].split(\">\");\n            }\n        }\n    }\n    return taggedPeriods;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvRGF0YS9CYW5rLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUEwQ1lBOzs7R0FBQUEsa0JBQUFBO0FBSUwsU0FBU0MsZ0JBQWdCQyxLQUFxQixFQUFFQyxRQUFnQixFQUFFQyxVQUFrQjtJQUN2RixJQUFJQyxXQUFvQixDQUFDO0lBQ3pCLElBQUlDLGNBQWNILFdBQVc7SUFFN0IsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlMLE1BQU1NLE1BQU0sRUFBRUQsSUFBSztRQUNuQyxNQUFNRSxPQUFPUCxLQUFLLENBQUNLLEVBQUU7UUFFckIsSUFBSUcsTUFBTU4sZUFBZSxLQUFLLElBQUlLLEtBQUtFLElBQUksQ0FBQ0MsT0FBTyxDQUFDUjtRQUNwRCxJQUFJUyxRQUFRUCxjQUFlSSxNQUFNRCxLQUFLRSxJQUFJLENBQUNILE1BQU0sR0FBSUw7UUFDckQsSUFBSVcsTUFBTUwsS0FBS0UsSUFBSSxDQUFDRSxNQUFNO1FBRTFCLElBQUlDLFFBQVFWLGNBQWNTLFFBQVNKLEtBQUtFLElBQUksQ0FBQ0gsTUFBTSxHQUFHLEdBQUk7WUFDdERNLE1BQU1MLEtBQUtFLElBQUksQ0FBQ0UsUUFBUSxFQUFFO1FBQzlCLE9BQ0ssSUFBSUMsUUFBUVYsY0FBY1MsVUFBV0osS0FBS0UsSUFBSSxDQUFDSCxNQUFNLEdBQUcsR0FBSTtZQUM3RE0sTUFBTVIsY0FBY0csS0FBS0UsSUFBSSxDQUFDLEVBQUUsR0FBRztRQUN2QztRQUVBLElBQUlHLE9BQU9ULFVBQVU7Z0JBQ09JO1lBQXhCSixRQUFRLENBQUNTLElBQUksQ0FBQ0MsTUFBTSxJQUFJTixDQUFBQSxlQUFBQSxLQUFLTSxNQUFNLGNBQVhOLDBCQUFBQSxlQUFlO2dCQUNoQkE7WUFBdkJKLFFBQVEsQ0FBQ1MsSUFBSSxDQUFDRSxLQUFLLElBQUlQLENBQUFBLGNBQUFBLEtBQUtPLEtBQUssY0FBVlAseUJBQUFBLGNBQWM7UUFDekMsT0FDSztn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QztJQUVBLElBQUlWLG1CQUFtQkwsUUFBUTtRQUMzQixPQUFPVyxpQkFBaUJYLE9BQU9lLElBQUk7SUFDdkM7SUFFQSxJQUFJUixrQkFBa0JQLFFBQVE7UUFDMUIsT0FBT2EsZ0JBQWdCYixPQUFPZSxJQUFJO0lBQ3RDO0lBRUEsT0FBT2YsTUFBTWUsSUFBSTtBQUNyQjtBQUVPLFNBQVNDLFdBQVdDLE9BQXlCLEVBQUVDLE9BQWlCO0lBQ25FLE1BQU1DLGdCQUFnQjtXQUFJRjtLQUFRO0lBQ2xDLElBQUssSUFBSWpFLElBQUksR0FBR0EsSUFBSW1FLGNBQWNsRSxNQUFNLEVBQUVELElBQUs7UUFDM0MsTUFBTThDLFNBQVNxQixhQUFhLENBQUNuRSxFQUFFO1FBQy9CLElBQUssSUFBSWdCLElBQUksR0FBR0EsSUFBSThCLE9BQU9uRCxLQUFLLENBQUNNLE1BQU0sRUFBRWUsSUFBSztZQUMxQyxNQUFNZCxPQUFPNEMsT0FBT25ELEtBQUssQ0FBQ3FCLEVBQUU7WUFDNUIsTUFBTW9ELEtBQUtOLG1CQUFtQjVELEtBQUs4QyxLQUFLO1lBQ3hDLElBQUlrQixPQUFPLENBQUNFLEdBQUcsRUFBRTtnQkFDYmxFLEtBQUtFLElBQUksR0FBRzhELE9BQU8sQ0FBQ0UsR0FBRyxDQUFDQyxLQUFLLENBQUM7WUFDbEM7UUFDSjtJQUNKO0lBQ0EsT0FBT0Y7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0RhdGEvQmFuay50cz82NzJkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgSUFjY291bnRMaW5lIHtcclxuICAgIGRhdGU6IERhdGU7XHJcbiAgICBkZWJpdDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgY3JlZGl0OiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBsYWJlbDogc3RyaW5nO1xyXG4gICAgYmFsYW5jZTogbnVtYmVyO1xyXG4gICAgdGFnczogc3RyaW5nW107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFjY291bnRMaW5lcyB7XHJcbiAgICBsaW5lczogSUFjY291bnRMaW5lW107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFjY291bnRQZXJpb2Qge1xyXG4gICAgYmVnaW46IERhdGU7XHJcbiAgICBlbmQ6IERhdGU7XHJcbiAgICBsaW5lczogSUFjY291bnRMaW5lW107XHJcbiAgICBpc0FnZ3JlZ2F0ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFRNYXBwaW5nID0ge1ttYXRjaDogc3RyaW5nXTogc3RyaW5nfVxyXG5leHBvcnQgaW50ZXJmYWNlIElNYXBwaW5nTGluZSB7XHJcbiAgICBtYXRjaDogc3RyaW5nO1xyXG4gICAgdGFnczogc3RyaW5nO1xyXG59XHJcbmV4cG9ydCB0eXBlIFRhZ0xpbmUgPSB7W2lkOiBzdHJpbmddOiB7Y3JlZGl0OiBudW1iZXIsIGRlYml0OiBudW1iZXIsIHN1YlRhZ3M6IFRhZ0xpbmV9OyB9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElUYWcge1xyXG4gICAgdGFnOiBzdHJpbmc7XHJcbiAgICBjb3VudDogbnVtYmVyO1xyXG4gICAgZnJlcXVlbmN5OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFRCdWRnZXQgPSB7W3RhZzogc3RyaW5nXTogbnVtYmVyfVxyXG5leHBvcnQgaW50ZXJmYWNlIElUYWdCdWRnZXQge1xyXG4gICAgdGFnOiBzdHJpbmc7XHJcbiAgICBhbGxvd2VkOiBudW1iZXI7XHJcbiAgICBjb25zdW1lZDogbnVtYmVyO1xyXG4gICAgbGluZXM6IElBY2NvdW50TGluZVtdO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGVudW0gRURvY3VtZW50VHlwZSB7XHJcbiAgICBBQ0NPVU5UOiBcIkFDQ09VTlRcIlxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWdncmVnYXRlQnlUYWdzKGxpbmVzOiBJQWNjb3VudExpbmVbXSwgdGFnTGV2ZWw6IG51bWJlciwgZXhjbHVkZVRhZzogc3RyaW5nKTogVGFnTGluZSB7XHJcbiAgICBsZXQgYWdyZWdhdGU6IFRhZ0xpbmUgPSB7fTtcclxuICAgIGxldCBpc1JlY3Vyc2l2ZSA9IHRhZ0xldmVsIDwgMDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xyXG5cclxuICAgICAgICBsZXQgaWR4ID0gZXhjbHVkZVRhZyA9PT0gXCJcIiA/IDAgOiBsaW5lLnRhZ3MuaW5kZXhPZihleGNsdWRlVGFnKTtcclxuICAgICAgICBsZXQgbGV2ZWwgPSBpc1JlY3Vyc2l2ZSA/IChpZHggJSBsaW5lLnRhZ3MubGVuZ3RoKSA6IHRhZ0xldmVsO1xyXG4gICAgICAgIGxldCB0YWcgPSBsaW5lLnRhZ3NbbGV2ZWxdO1xyXG5cclxuICAgICAgICBpZiAodGFnID09PSBleGNsdWRlVGFnICYmIGxldmVsIDwgKGxpbmUudGFncy5sZW5ndGggLSAxKSkge1xyXG4gICAgICAgICAgICB0YWcgPSBsaW5lLnRhZ3NbbGV2ZWwgKyAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGFnID09PSBleGNsdWRlVGFnICYmIGxldmVsID09PSAobGluZS50YWdzLmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgIHRhZyA9IGlzUmVjdXJzaXZlID8gbGluZS50YWdzWzBdIDogXCJVbmRlZmluZWRcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0YWcgaW4gYWdyZWdhdGUpIHtcclxuICAgICAgICAgICAgYWdyZWdhdGVbdGFnXS5jcmVkaXQgKz0gbGluZS5jcmVkaXQgPz8gMDtcclxuICAgICAgICAgICAgYWdyZWdhdGVbdGFnXS5kZWJpdCArPSBsaW5lLmRlYml0ID8/IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhZ3JlZ2F0ZVt0YWddID0ge1xyXG4gICAgICAgICAgICAgICAgY3JlZGl0OiBsaW5lLmNyZWRpdCA/PyAwLFxyXG4gICAgICAgICAgICAgICAgZGViaXQ6IGxpbmUuZGViaXQgPz8gMCxcclxuICAgICAgICAgICAgICAgIHN1YlRhZ3M6IHt9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFncmVnYXRlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFRhZ3MobGluZXM6IElBY2NvdW50TGluZVtdKTogc3RyaW5nW10ge1xyXG4gICAgbGV0IHRhZ3M6IHN0cmluZ1tdID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGFncy5wdXNoKC4uLmxpbmVzW2ldLnRhZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzXHJcbiAgICB0YWdzID0gdGFncy5maWx0ZXIoZnVuY3Rpb24odGFnLCBpZHgpIHtcclxuICAgICAgICByZXR1cm4gdGFncy5pbmRleE9mKHRhZykgPT09IGlkeDtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0YWdzLnNvcnQoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUYWdzV2l0aENvdW50KGxpbmVzOiBJQWNjb3VudExpbmVbXSk6IElUYWdbXSB7XHJcbiAgICBsZXQgdGFnczogSVRhZ1tdID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lc1tpXS50YWdzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZ0lkeCA9IHRhZ3MuZmluZEluZGV4KCh0YWcpID0+IHRhZy50YWcgPT09IGxpbmVzW2ldLnRhZ3Nbal0pO1xyXG4gICAgICAgICAgICBpZiAodGFnSWR4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGFncy5wdXNoKHt0YWc6IGxpbmVzW2ldLnRhZ3Nbal0sIGNvdW50OiAxLCBmcmVxdWVuY3k6IDEvbGluZXMubGVuZ3RofSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0YWdzW3RhZ0lkeF0uY291bnQrKztcclxuICAgICAgICAgICAgICAgIHRhZ3NbdGFnSWR4XS5mcmVxdWVuY3kgPSB0YWdzW3RhZ0lkeF0uY291bnQvbGluZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YWdzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICBjb25zdCBmcmVxQSA9IE1hdGguZmxvb3IoYS5mcmVxdWVuY3kgKiAxMDApO1xyXG4gICAgICAgIGNvbnN0IGZyZXFCID0gTWF0aC5mbG9vcihiLmZyZXF1ZW5jeSAqIDEwMCk7XHJcbiAgICAgICAgaWYgKGZyZXFBID09PSBmcmVxQikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS50YWcgPiBiLnRhZyA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChNYXRoLmZsb29yKGIuZnJlcXVlbmN5ICogMTAwKSAtIE1hdGguZmxvb3IoYS5mcmVxdWVuY3kgKiAxMDApKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWdncmVnYXRlQnlUYWcobGluZXM6IElBY2NvdW50TGluZVtdLCB0YWc6IHN0cmluZyk6IFRhZ0xpbmUge1xyXG4gICAgbGV0IGFncmVnYXRlOiBUYWdMaW5lID0ge307XHJcbiAgICBjb25zdCB0YWdnZWRMaW5lcyA9IHRhZyA9PT0gXCJcIiA/IGxpbmVzIDogbGluZXMuZmlsdGVyKChsaW5lKSA9PiBsaW5lLnRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWdnZWRMaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGxpbmUgPSB0YWdnZWRMaW5lc1tpXTtcclxuICAgICAgICBpZiAodGFnIGluIGFncmVnYXRlKSB7XHJcbiAgICAgICAgICAgIGFncmVnYXRlW3RhZ10uY3JlZGl0ICs9IGxpbmUuY3JlZGl0ID8/IDA7XHJcbiAgICAgICAgICAgIGFncmVnYXRlW3RhZ10uZGViaXQgKz0gbGluZS5kZWJpdCA/PyAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWdyZWdhdGVbdGFnXSA9IHtcclxuICAgICAgICAgICAgICAgIGNyZWRpdDogbGluZS5jcmVkaXQgPz8gMCxcclxuICAgICAgICAgICAgICAgIGRlYml0OiBsaW5lLmRlYml0ID8/IDAsXHJcbiAgICAgICAgICAgICAgICBzdWJUYWdzOiB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWdyZWdhdGVbdGFnXS5zdWJUYWdzID0gYWdncmVnYXRlQnlUYWdzKHRhZ2dlZExpbmVzLCAwLCB0YWcpO1xyXG4gICAgcmV0dXJuIGFncmVnYXRlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWdncmVnYXRlQnlEYXRlKGxpbmVzOiBJQWNjb3VudExpbmVbXSwgbW9udGhseTogYm9vbGVhbiA9IGZhbHNlKTogVGFnTGluZSB7XHJcbiAgICBsZXQgYWdyZWdhdGU6IFRhZ0xpbmUgPSB7fTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgICAgIGxldCBzdHJEYXRlID0gbGluZS5kYXRlLnRvTG9jYWxlRGF0ZVN0cmluZyhcImZyLUZSXCIpO1xyXG4gICAgICAgIGlmIChtb250aGx5KSB7XHJcbiAgICAgICAgICAgIHN0ckRhdGUgPSBzdHJEYXRlLnNsaWNlKHN0ckRhdGUuaW5kZXhPZihcIi9cIikrMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdHJEYXRlIGluIGFncmVnYXRlKSB7XHJcbiAgICAgICAgICAgIGFncmVnYXRlW3N0ckRhdGVdLmNyZWRpdCArPSBsaW5lLmNyZWRpdCA/PyAwO1xyXG4gICAgICAgICAgICBhZ3JlZ2F0ZVtzdHJEYXRlXS5kZWJpdCArPSBsaW5lLmRlYml0ID8/IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhZ3JlZ2F0ZVtzdHJEYXRlXSA9IHtcclxuICAgICAgICAgICAgICAgIGNyZWRpdDogbGluZS5jcmVkaXQgPz8gMCxcclxuICAgICAgICAgICAgICAgIGRlYml0OiBsaW5lLmRlYml0ID8/IDAsXHJcbiAgICAgICAgICAgICAgICBzdWJUYWdzOiB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFncmVnYXRlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNjb3VudFBlcmlvZFN0cihhY2NvdW50OiBJQWNjb3VudFBlcmlvZCk6IHN0cmluZyB7XHJcbiAgICBsZXQgYWdncmVnYXRlZE1lbnRpb24gPSBhY2NvdW50LmlzQWdncmVnYXRlZCA/IFwiIChBZ2dyZWdhdGVkKSBcIiA6IFwiXCI7XHJcbiAgICByZXR1cm4gYWNjb3VudC5iZWdpbi50b0xvY2FsZURhdGVTdHJpbmcoKSArIFwiIC0gXCIgKyBhY2NvdW50LmVuZC50b0xvY2FsZURhdGVTdHJpbmcoKSArIGFnZ3JlZ2F0ZWRNZW50aW9uO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2hvbGVQZXJpb2QoYWNjb3VudHM6IElBY2NvdW50UGVyaW9kW10pOiBJQWNjb3VudFBlcmlvZCB7XHJcbiAgICBjb25zdCB3aG9sZVBlcmlvZDogSUFjY291bnRQZXJpb2QgPSBhY2NvdW50cy5yZWR1Y2UoKHJlc3VsdCwgcGVyaW9kKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHsuLi5yZXN1bHQsXHJcbiAgICAgICAgICAgIGJlZ2luOiBwZXJpb2QuYmVnaW4gPCByZXN1bHQuYmVnaW4gPyBwZXJpb2QuYmVnaW4gOiByZXN1bHQuYmVnaW4sXHJcbiAgICAgICAgICAgIGVuZDogcGVyaW9kLmJlZ2luID4gcmVzdWx0LmJlZ2luID8gcGVyaW9kLmJlZ2luIDogcmVzdWx0LmJlZ2luLFxyXG4gICAgICAgICAgICBsaW5lczogWy4uLnJlc3VsdC5saW5lcywgLi4ucGVyaW9kLmxpbmVzXSxcclxuICAgICAgICAgICAgaXNBZ2dyZWdhdGVkOiB0cnVlfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHdob2xlUGVyaW9kLmxpbmVzLnNvcnQoKGE6IElBY2NvdW50TGluZSwgYjogSUFjY291bnRMaW5lKSA9PiB7cmV0dXJuIGEuZGF0ZSA+IGIuZGF0ZSA/IDEgOiAtMTt9KTtcclxuICAgIHJldHVybiB3aG9sZVBlcmlvZDtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1BheW1lbnRMYWJlbChsYWJlbDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKC8oUEFJRU1FTlRcXHMpLyk7XHJcbiAgICBjb25zdCB0ZXN0ID0gcmVnRXhwLnRlc3QobGFiZWwudG9VcHBlckNhc2UoKSk7XHJcbiAgICByZXR1cm4gdGVzdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRGlyZWN0RGViaXRMYWJlbChsYWJlbDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKC8oUFJMVlxcc1NFUEFcXHMpLyk7XHJcbiAgICBjb25zdCB0ZXN0ID0gcmVnRXhwLnRlc3QobGFiZWwudG9VcHBlckNhc2UoKSk7XHJcbiAgICByZXR1cm4gdGVzdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzQmFua1RyYW5zZmVyTGFiZWwobGFiZWw6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cCgvKFZJUlxccykvKTtcclxuICAgIGNvbnN0IHRlc3QgPSByZWdFeHAudGVzdChsYWJlbC50b1VwcGVyQ2FzZSgpKTtcclxuICAgIHJldHVybiB0ZXN0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNXaXRoZHJhd2FsTGFiZWwobGFiZWw6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cCgvKFJFVFJBSVRcXHNEQUJcXHMpLyk7XHJcbiAgICBjb25zdCB0ZXN0ID0gcmVnRXhwLnRlc3QobGFiZWwudG9VcHBlckNhc2UoKSk7XHJcbiAgICByZXR1cm4gdGVzdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBheW1lbnRJZChsYWJlbDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIC8vUEFJRU1FTlQgQ0IgMzAwNyBGUiBMWU9OIExBLUJBUkdFIENBUlRFIDIxNzhcclxuICAgIGNvbnN0IG1hdGNoZXMgPSBsYWJlbC50b1VwcGVyQ2FzZSgpLm1hdGNoKC8oPzpQQUlFTUVOVFxccyg/OkNCfFBTQylcXHNcXGRcXGRcXGRcXGRcXHMpKChbYS16QS1aXXwtfF98XFxkK3xcXC98XFwqfFxccykrKSg/OkNBUlRFXFxzXFxkXFxkXFxkXFxkKS8pO1xyXG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzFdIDogXCJcIjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERpcmVjdERlYml0SWQobGFiZWw6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBtYXRjaGVzID0gbGFiZWwudG9VcHBlckNhc2UoKS5tYXRjaCgvKD86UFJMVlxcc1NFUEFcXHMpKChbYS16QS1aXXwtfF98XFxzKSspLyk7XHJcbiAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiBcIlwiO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFua1RyYW5zZmVySWQobGFiZWw6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBtYXRjaGVzID0gbGFiZWwudG9VcHBlckNhc2UoKS5tYXRjaCgvKD86VklSXFxzKSgoW2EtekEtWl18LXxffFxccykrKS8pO1xyXG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzFdIDogXCJcIjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFdpdGhkcmF3YWxJZChsYWJlbDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IG1hdGNoZXMgPSBsYWJlbC50b1VwcGVyQ2FzZSgpLm1hdGNoKC9SRVRSQUlUIERBQi8pO1xyXG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogXCJcIjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RJZEZyb21MYWJlbChsYWJlbDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGlmIChpc0JhbmtUcmFuc2ZlckxhYmVsKGxhYmVsKSkge1xyXG4gICAgICAgIHJldHVybiBnZXRCYW5rVHJhbnNmZXJJZChsYWJlbCkudHJpbSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc1BheW1lbnRMYWJlbChsYWJlbCkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0UGF5bWVudElkKGxhYmVsKS50cmltKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzRGlyZWN0RGViaXRMYWJlbChsYWJlbCkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGlyZWN0RGViaXRJZChsYWJlbCkudHJpbSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc1dpdGhkcmF3YWxMYWJlbChsYWJlbCkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0V2l0aGRyYXdhbElkKGxhYmVsKS50cmltKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxhYmVsLnRyaW0oKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRhZ1BlcmlvZHMocGVyaW9kczogSUFjY291bnRQZXJpb2RbXSwgbWFwcGluZzogVE1hcHBpbmcpOiBJQWNjb3VudFBlcmlvZFtdIHtcclxuICAgIGNvbnN0IHRhZ2dlZFBlcmlvZHMgPSBbLi4ucGVyaW9kc107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhZ2dlZFBlcmlvZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwZXJpb2QgPSB0YWdnZWRQZXJpb2RzW2ldO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGVyaW9kLmxpbmVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBwZXJpb2QubGluZXNbal07XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZXh0cmFjdElkRnJvbUxhYmVsKGxpbmUubGFiZWwpO1xyXG4gICAgICAgICAgICBpZiAobWFwcGluZ1tpZF0pIHtcclxuICAgICAgICAgICAgICAgIGxpbmUudGFncyA9IG1hcHBpbmdbaWRdLnNwbGl0KCc+Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFnZ2VkUGVyaW9kcztcclxufSJdLCJuYW1lcyI6WyJFRG9jdW1lbnRUeXBlIiwiYWdncmVnYXRlQnlUYWdzIiwibGluZXMiLCJ0YWdMZXZlbCIsImV4Y2x1ZGVUYWciLCJhZ3JlZ2F0ZSIsImlzUmVjdXJzaXZlIiwiaSIsImxlbmd0aCIsImxpbmUiLCJpZHgiLCJ0YWdzIiwiaW5kZXhPZiIsImxldmVsIiwidGFnIiwiY3JlZGl0IiwiZGViaXQiLCJzdWJUYWdzIiwiZXh0cmFjdFRhZ3MiLCJwdXNoIiwiZmlsdGVyIiwic29ydCIsImV4dHJhY3RUYWdzV2l0aENvdW50IiwiaiIsInRhZ0lkeCIsImZpbmRJbmRleCIsImNvdW50IiwiZnJlcXVlbmN5IiwiYSIsImIiLCJmcmVxQSIsIk1hdGgiLCJmbG9vciIsImZyZXFCIiwiYWdncmVnYXRlQnlUYWciLCJ0YWdnZWRMaW5lcyIsImFnZ3JlZ2F0ZUJ5RGF0ZSIsIm1vbnRobHkiLCJzdHJEYXRlIiwiZGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInNsaWNlIiwiZ2V0QWNjb3VudFBlcmlvZFN0ciIsImFjY291bnQiLCJhZ2dyZWdhdGVkTWVudGlvbiIsImlzQWdncmVnYXRlZCIsImJlZ2luIiwiZW5kIiwiZ2V0V2hvbGVQZXJpb2QiLCJhY2NvdW50cyIsIndob2xlUGVyaW9kIiwicmVkdWNlIiwicmVzdWx0IiwicGVyaW9kIiwiaXNQYXltZW50TGFiZWwiLCJsYWJlbCIsInJlZ0V4cCIsIlJlZ0V4cCIsInRlc3QiLCJ0b1VwcGVyQ2FzZSIsImlzRGlyZWN0RGViaXRMYWJlbCIsImlzQmFua1RyYW5zZmVyTGFiZWwiLCJpc1dpdGhkcmF3YWxMYWJlbCIsImdldFBheW1lbnRJZCIsIm1hdGNoZXMiLCJtYXRjaCIsImdldERpcmVjdERlYml0SWQiLCJnZXRCYW5rVHJhbnNmZXJJZCIsImdldFdpdGhkcmF3YWxJZCIsImV4dHJhY3RJZEZyb21MYWJlbCIsInRyaW0iLCJ0YWdQZXJpb2RzIiwicGVyaW9kcyIsIm1hcHBpbmciLCJ0YWdnZWRQZXJpb2RzIiwiaWQiLCJzcGxpdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Data/Bank.ts\n"));

/***/ })

});