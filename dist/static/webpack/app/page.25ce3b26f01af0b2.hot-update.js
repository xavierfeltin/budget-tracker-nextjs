"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Data/Bank.ts":
/*!*********************************!*\
  !*** ./components/Data/Bank.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EDocumentType: function() { return /* binding */ EDocumentType; },\n/* harmony export */   aggregateByDate: function() { return /* binding */ aggregateByDate; },\n/* harmony export */   aggregateByTag: function() { return /* binding */ aggregateByTag; },\n/* harmony export */   aggregateByTags: function() { return /* binding */ aggregateByTags; },\n/* harmony export */   computeQuartileValue: function() { return /* binding */ computeQuartileValue; },\n/* harmony export */   extractBoxPlotFromData: function() { return /* binding */ extractBoxPlotFromData; },\n/* harmony export */   extractIdFromLabel: function() { return /* binding */ extractIdFromLabel; },\n/* harmony export */   extractTags: function() { return /* binding */ extractTags; },\n/* harmony export */   extractTagsWithCount: function() { return /* binding */ extractTagsWithCount; },\n/* harmony export */   getAccountPeriodStr: function() { return /* binding */ getAccountPeriodStr; },\n/* harmony export */   getBankTransferId: function() { return /* binding */ getBankTransferId; },\n/* harmony export */   getBoxPlotsFromLines: function() { return /* binding */ getBoxPlotsFromLines; },\n/* harmony export */   getDirectDebitId: function() { return /* binding */ getDirectDebitId; },\n/* harmony export */   getPaymentId: function() { return /* binding */ getPaymentId; },\n/* harmony export */   getWholePeriod: function() { return /* binding */ getWholePeriod; },\n/* harmony export */   getWithdrawalId: function() { return /* binding */ getWithdrawalId; },\n/* harmony export */   isBankTransferLabel: function() { return /* binding */ isBankTransferLabel; },\n/* harmony export */   isDirectDebitLabel: function() { return /* binding */ isDirectDebitLabel; },\n/* harmony export */   isPaymentLabel: function() { return /* binding */ isPaymentLabel; },\n/* harmony export */   isWithdrawalLabel: function() { return /* binding */ isWithdrawalLabel; },\n/* harmony export */   tagPeriods: function() { return /* binding */ tagPeriods; }\n/* harmony export */ });\nvar EDocumentType;\n(function(EDocumentType) {\n    EDocumentType[\"ACCOUNT\"] = \"ACCOUNT\";\n    EDocumentType[\"MAPPING\"] = \"MAPPING\";\n    EDocumentType[\"BUDGET\"] = \"BUDGET\";\n})(EDocumentType || (EDocumentType = {}));\nfunction aggregateByTags(lines, tagLevel, excludeTag) {\n    let agregate = {};\n    let isRecursive = tagLevel < 0;\n    for(let i = 0; i < lines.length; i++){\n        const line = lines[i];\n        let idx = excludeTag === \"\" ? 0 : line.tags.indexOf(excludeTag);\n        let level = isRecursive ? idx % line.tags.length : tagLevel;\n        let tag = line.tags[level];\n        if (tag === excludeTag && level < line.tags.length - 1) {\n            tag = line.tags[level + 1];\n        } else if (tag === excludeTag && level === line.tags.length - 1) {\n            tag = isRecursive ? line.tags[0] : \"Undefined\";\n        }\n        if (tag in agregate) {\n            var _line_credit;\n            agregate[tag].credit += (_line_credit = line.credit) !== null && _line_credit !== void 0 ? _line_credit : 0;\n            var _line_debit;\n            agregate[tag].debit += (_line_debit = line.debit) !== null && _line_debit !== void 0 ? _line_debit : 0;\n        } else {\n            var _line_credit1, _line_debit1;\n            agregate[tag] = {\n                credit: (_line_credit1 = line.credit) !== null && _line_credit1 !== void 0 ? _line_credit1 : 0,\n                debit: (_line_debit1 = line.debit) !== null && _line_debit1 !== void 0 ? _line_debit1 : 0,\n                subTags: {}\n            };\n        }\n    }\n    return agregate;\n}\nfunction extractTags(lines) {\n    let tags = [];\n    for(let i = 0; i < lines.length; i++){\n        tags.push(...lines[i].tags);\n    }\n    // Remove duplicates\n    tags = tags.filter(function(tag, idx) {\n        return tags.indexOf(tag) === idx;\n    });\n    return tags.sort();\n}\nfunction extractTagsWithCount(lines, startingTag) {\n    let tags = [];\n    debugger;\n    for(let i = 0; i < lines.length; i++){\n        let startIdx = 0;\n        let endIdx = lines[i].tags.length;\n        if (startingTag) {\n            // Consider only the next after the startingTag\n            const idx = lines[i].tags.findIndex((tag)=>tag === startingTag);\n            if (idx === lines[i].tags.length - 1) {\n                continue;\n            // If startingTag is the last one in the tag list, consider the first tag of the list instead\n            //startIdx = 0;\n            //endIdx = 1;\n            }\n            startIdx = idx + 1;\n            endIdx = idx + 2;\n            console.log(\"starting tag idx \" + startIdx);\n        }\n        for(let j = startIdx; j < endIdx; j++){\n            if (lines[i].tags[j] === startingTag) {\n                debugger;\n            }\n            const tagIdx = tags.findIndex((tag)=>tag.tag === lines[i].tags[j]);\n            if (tagIdx === -1) {\n                tags.push({\n                    tag: lines[i].tags[j],\n                    count: 1,\n                    frequency: 1 / lines.length\n                });\n            } else {\n                tags[tagIdx].count++;\n                tags[tagIdx].frequency = tags[tagIdx].count / lines.length;\n            }\n        }\n    }\n    return tags.sort((a, b)=>{\n        const freqA = Math.floor(a.frequency * 100);\n        const freqB = Math.floor(b.frequency * 100);\n        if (freqA === freqB) {\n            return a.tag > b.tag ? 1 : -1;\n        }\n        return Math.floor(b.frequency * 100) - Math.floor(a.frequency * 100);\n    });\n}\nfunction aggregateByTag(lines, tag) {\n    let agregate = {};\n    const taggedLines = tag === \"\" ? lines : lines.filter((line)=>line.tags.indexOf(tag) !== -1);\n    for(let i = 0; i < taggedLines.length; i++){\n        const line = taggedLines[i];\n        if (tag in agregate) {\n            var _line_credit;\n            agregate[tag].credit += (_line_credit = line.credit) !== null && _line_credit !== void 0 ? _line_credit : 0;\n            var _line_debit;\n            agregate[tag].debit += (_line_debit = line.debit) !== null && _line_debit !== void 0 ? _line_debit : 0;\n        } else {\n            var _line_credit1, _line_debit1;\n            agregate[tag] = {\n                credit: (_line_credit1 = line.credit) !== null && _line_credit1 !== void 0 ? _line_credit1 : 0,\n                debit: (_line_debit1 = line.debit) !== null && _line_debit1 !== void 0 ? _line_debit1 : 0,\n                subTags: {}\n            };\n        }\n    }\n    agregate[tag].subTags = aggregateByTags(taggedLines, 0, tag);\n    return agregate;\n}\nfunction aggregateByDate(lines) {\n    let monthly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    let agregate = {};\n    for(let i = 0; i < lines.length; i++){\n        const line = lines[i];\n        let strDate = line.date.toLocaleDateString(\"fr-FR\");\n        if (monthly) {\n            strDate = strDate.slice(strDate.indexOf(\"/\") + 1);\n        }\n        if (strDate in agregate) {\n            var _line_credit;\n            agregate[strDate].credit += (_line_credit = line.credit) !== null && _line_credit !== void 0 ? _line_credit : 0;\n            var _line_debit;\n            agregate[strDate].debit += (_line_debit = line.debit) !== null && _line_debit !== void 0 ? _line_debit : 0;\n        } else {\n            var _line_credit1, _line_debit1;\n            agregate[strDate] = {\n                credit: (_line_credit1 = line.credit) !== null && _line_credit1 !== void 0 ? _line_credit1 : 0,\n                debit: (_line_debit1 = line.debit) !== null && _line_debit1 !== void 0 ? _line_debit1 : 0,\n                subTags: {}\n            };\n        }\n    }\n    return agregate;\n}\nfunction getAccountPeriodStr(account) {\n    let aggregatedMention = account.isAggregated ? \" (Aggregated) \" : \"\";\n    return account.begin.toLocaleDateString() + \" - \" + account.end.toLocaleDateString() + aggregatedMention;\n}\nfunction getWholePeriod(accounts) {\n    const wholePeriod = accounts.reduce((result, period)=>{\n        return {\n            ...result,\n            begin: period.begin < result.begin ? period.begin : result.begin,\n            end: period.begin > result.begin ? period.begin : result.begin,\n            lines: [\n                ...result.lines,\n                ...period.lines\n            ],\n            isAggregated: true\n        };\n    });\n    wholePeriod.lines.sort((a, b)=>{\n        return a.date.getTime() === b.date.getTime() ? 0 : a.date.getTime() > b.date.getTime() ? 1 : -1;\n    });\n    return wholePeriod;\n}\nfunction isPaymentLabel(label) {\n    const regExp = new RegExp(/(PAIEMENT\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction isDirectDebitLabel(label) {\n    const regExp = new RegExp(/(PRLV\\sSEPA\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction isBankTransferLabel(label) {\n    const regExp = new RegExp(/(VIR\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction isWithdrawalLabel(label) {\n    const regExp = new RegExp(/(RETRAIT\\sDAB\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction getPaymentId(label) {\n    //PAIEMENT CB 3007 FR LYON LA-BARGE CARTE 2178\n    const matches = label.toUpperCase().match(/(?:PAIEMENT\\s(?:CB|PSC)\\s\\d\\d\\d\\d\\s)(([a-zA-Z]|-|_|\\d+|\\/|\\*|\\s)+)(?:CARTE\\s\\d\\d\\d\\d)/);\n    return matches ? matches[1] : \"\";\n}\nfunction getDirectDebitId(label) {\n    const matches = label.toUpperCase().match(/(?:PRLV\\sSEPA\\s)(([a-zA-Z]|-|_|\\s)+)/);\n    return matches ? matches[1] : \"\";\n}\nfunction getBankTransferId(label) {\n    const matches = label.toUpperCase().match(/(?:VIR\\s)(([a-zA-Z]|-|_|\\s)+)/);\n    return matches ? matches[1] : \"\";\n}\nfunction getWithdrawalId(label) {\n    const matches = label.toUpperCase().match(/RETRAIT DAB/);\n    return matches ? matches[0] : \"\";\n}\nfunction extractIdFromLabel(label) {\n    if (isBankTransferLabel(label)) {\n        return getBankTransferId(label).trim();\n    }\n    if (isPaymentLabel(label)) {\n        return getPaymentId(label).trim();\n    }\n    if (isDirectDebitLabel(label)) {\n        return getDirectDebitId(label).trim();\n    }\n    if (isWithdrawalLabel(label)) {\n        return getWithdrawalId(label).trim();\n    }\n    return label.trim();\n}\nfunction tagPeriods(periods, mapping) {\n    const taggedPeriods = [\n        ...periods\n    ];\n    for(let i = 0; i < taggedPeriods.length; i++){\n        const period = taggedPeriods[i];\n        for(let j = 0; j < period.lines.length; j++){\n            const line = period.lines[j];\n            const id = extractIdFromLabel(line.label);\n            if (mapping[id]) {\n                line.tags = mapping[id].split(\">\");\n            }\n        }\n    }\n    return taggedPeriods;\n}\nfunction getBoxPlotsFromLines(allAccountLines) {\n    const step = 10;\n    const boxPlotByStep = [];\n    let values = allAccountLines.filter((line)=>line.pctInMonth < 5).map((line)=>line.balance).sort((a, b)=>a - b);\n    let boxPlot = extractBoxPlotFromData(values);\n    boxPlot.pctInMonth = 1;\n    boxPlotByStep.push(boxPlot);\n    for(let i = 5; i <= 95; i += step){\n        let values = allAccountLines.filter((line)=>line.pctInMonth >= i - 5 && line.pctInMonth < i + 5).map((line)=>line.balance).sort((a, b)=>a - b);\n        const boxPlot = extractBoxPlotFromData(values);\n        boxPlot.pctInMonth = i;\n        boxPlotByStep.push(boxPlot);\n    }\n    values = allAccountLines.filter((line)=>line.pctInMonth >= 95).map((line)=>line.balance).sort((a, b)=>a - b);\n    boxPlot = extractBoxPlotFromData(values);\n    boxPlot.pctInMonth = 100;\n    boxPlotByStep.push(boxPlot);\n    return boxPlotByStep;\n}\nfunction extractBoxPlotFromData(data) {\n    if (data.length === 0) {\n        return {\n            pctInMonth: NaN,\n            firstQuartile: NaN,\n            thirdQuartile: NaN,\n            mediane: NaN,\n            mean: NaN,\n            minimum: NaN,\n            maximum: NaN\n        };\n    }\n    const firstQuartileIdx = Math.max(0, (data.length + 3) / 4 - 1);\n    const thirdQuartileIdx = Math.max(0, (3 * data.length + 1) / 4 - 1);\n    let mediane;\n    if (data.length % 2 === 0 && data.length > 2) {\n        const lowerIdx = data.length / 2 - 2;\n        const upperIdx = data.length / 2 - 1;\n        mediane = (data[lowerIdx] + data[upperIdx]) / 2;\n    } else {\n        const idx = Math.max(0, (data.length + 1) / 2 - 1);\n        mediane = data[idx];\n    }\n    let mean = 0;\n    mean = data.reduce((a, b)=>a + b);\n    mean = mean / data.length;\n    return {\n        pctInMonth: NaN,\n        firstQuartile: computeQuartileValue(firstQuartileIdx, data),\n        thirdQuartile: computeQuartileValue(thirdQuartileIdx, data),\n        mediane: mediane,\n        mean: mean,\n        minimum: data[0],\n        maximum: data[data.length - 1]\n    };\n}\nfunction computeQuartileValue(quartileIdx, data) {\n    if (Number.isInteger(quartileIdx)) {\n        return data[quartileIdx];\n    }\n    const lowerIdx = Math.ceil(quartileIdx);\n    const upperIdx = Math.floor(quartileIdx);\n    let coeff1 = 1;\n    let coeff2 = 1;\n    if (quartileIdx - lowerIdx === 0.25) {\n        coeff1 = 3;\n    } else if (quartileIdx - lowerIdx === 0.75) {\n        coeff2 = 3;\n    }\n    // else {  (quartileIdx - lowerIdx === 0.5) {\n    //coeff1 = 1, coeff2 = 1\n    return (data[lowerIdx] * coeff1 + data[upperIdx] * coeff2) / (coeff1 + coeff2);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvRGF0YS9CYW5rLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUFpRFlBOzs7O0dBQUFBLGtCQUFBQTtBQU1MLFNBQVNDLGdCQUFnQkMsS0FBcUIsRUFBRUMsUUFBZ0IsRUFBRUMsVUFBa0I7SUFDdkYsSUFBSUMsV0FBb0IsQ0FBQztJQUN6QixJQUFJQyxjQUFjSCxXQUFXO0lBRTdCLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7UUFDbkMsTUFBTUUsT0FBT1AsS0FBSyxDQUFDSyxFQUFFO1FBRXJCLElBQUlHLE1BQU1OLGVBQWUsS0FBSyxJQUFJSyxLQUFLRSxJQUFJLENBQUNDLE9BQU8sQ0FBQ1I7UUFDcEQsSUFBSVMsUUFBUVAsY0FBZUksTUFBTUQsS0FBS0UsSUFBSSxDQUFDSCxNQUFNLEdBQUlMO1FBQ3JELElBQUlXLE1BQU1MLEtBQUtFLElBQUksQ0FBQ0UsTUFBTTtRQUUxQixJQUFJQyxRQUFRVixjQUFjUyxRQUFTSixLQUFLRSxJQUFJLENBQUNILE1BQU0sR0FBRyxHQUFJO1lBQ3RETSxNQUFNTCxLQUFLRSxJQUFJLENBQUNFLFFBQVEsRUFBRTtRQUM5QixPQUNLLElBQUlDLFFBQVFWLGNBQWNTLFVBQVdKLEtBQUtFLElBQUksQ0FBQ0gsTUFBTSxHQUFHLEdBQUk7WUFDN0RNLE1BQU1SLGNBQWNHLEtBQUtFLElBQUksQ0FBQyxFQUFFLEdBQUc7UUFDdkM7UUFFQSxJQUFJRyxPQUFPVCxVQUFVO2dCQUNPSTtZQUF4QkosUUFBUSxDQUFDUyxJQUFJLENBQUNDLE1BQU0sSUFBSU4sQ0FBQUEsZUFBQUEsS0FBS00sTUFBTSxjQUFYTiwwQkFBQUEsZUFBZTtnQkFDaEJBO1lBQXZCSixRQUFRLENBQUNTLElBQUksQ0FBQ0UsS0FBSyxJQUFJUCxDQUFBQSxjQUFBQSxLQUFLTyxLQUFLLGNBQVZQLHlCQUFBQSxjQUFjO1FBQ3pDLE9BQ0s7Z0JBRVdBLGVBQ0RBO1lBRlhKLFFBQVEsQ0FBQ1MsSUFBSSxHQUFHO2dCQUNaQyxRQUFRTixDQUFBQSxnQkFBQUEsS0FBS00sTUFBTSxjQUFYTiwyQkFBQUEsZ0JBQWU7Z0JBQ3ZCTyxPQUFPUCxDQUFBQSxlQUFBQSxLQUFLTyxLQUFLLGNBQVZQLDBCQUFBQSxlQUFjO2dCQUNyQlEsU0FBUyxDQUFDO1lBQ2Q7UUFDSjtJQUNKO0lBRUEsT0FBT1o7QUFDWDtBQUVPLFNBQVNhLFlBQVloQixLQUFxQjtJQUM3QyxJQUFJUyxPQUFpQixFQUFFO0lBQ3ZCLElBQUssSUFBSUosSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7UUFDbkNJLEtBQUtRLElBQUksSUFBSWpCLEtBQUssQ0FBQ0ssRUFBRSxDQUFDSSxJQUFJO0lBQzlCO0lBRUEsb0JBQW9CO0lBQ3BCQSxPQUFPQSxLQUFLUyxNQUFNLENBQUMsU0FBU04sR0FBRyxFQUFFSixHQUFHO1FBQ2hDLE9BQU9DLEtBQUtDLE9BQU8sQ0FBQ0UsU0FBU0o7SUFDakM7SUFFQSxPQUFPQyxLQUFLVSxJQUFJO0FBQ3BCO0FBRU8sU0FBU0MscUJBQXFCcEIsS0FBcUIsRUFBRXFCLFdBQStCO0lBQ3ZGLElBQUlaLE9BQWUsRUFBRTtJQUVyQixRQUFTO0lBQ1QsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUlMLE1BQU1NLE1BQU0sRUFBRUQsSUFBSztRQUNuQyxJQUFJaUIsV0FBVztRQUNmLElBQUlDLFNBQVN2QixLQUFLLENBQUNLLEVBQUUsQ0FBQ0ksSUFBSSxDQUFDSCxNQUFNO1FBRWpDLElBQUllLGFBQWE7WUFDYiwrQ0FBK0M7WUFDL0MsTUFBTWIsTUFBTVIsS0FBSyxDQUFDSyxFQUFFLENBQUNJLElBQUksQ0FBQ2UsU0FBUyxDQUFDLENBQUNaLE1BQVFBLFFBQVFTO1lBQ3JELElBQUliLFFBQVNSLEtBQUssQ0FBQ0ssRUFBRSxDQUFDSSxJQUFJLENBQUNILE1BQU0sR0FBRyxHQUFJO2dCQUVwQztZQUNBLDZGQUE2RjtZQUM3RixlQUFlO1lBQ2YsYUFBYTtZQUNqQjtZQUVBZ0IsV0FBV2QsTUFBTTtZQUNqQmUsU0FBU2YsTUFBTTtZQUNmaUIsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQko7UUFDdEM7UUFFQSxJQUFLLElBQUlLLElBQUlMLFVBQVVLLElBQUlKLFFBQVFJLElBQUs7WUFFcEMsSUFBRzNCLEtBQUssQ0FBQ0ssRUFBRSxDQUFDSSxJQUFJLENBQUNrQixFQUFFLEtBQUtOLGFBQWE7Z0JBQ2pDLFFBQVM7WUFDYjtZQUVBLE1BQU1PLFNBQVNuQixLQUFLZSxTQUFTLENBQUMsQ0FBQ1osTUFBUUEsSUFBSUEsR0FBRyxLQUFLWixLQUFLLENBQUNLLEVBQUUsQ0FBQ0ksSUFBSSxDQUFDa0IsRUFBRTtZQUNuRSxJQUFJQyxXQUFXLENBQUMsR0FBRztnQkFDZm5CLEtBQUtRLElBQUksQ0FBQztvQkFBQ0wsS0FBS1osS0FBSyxDQUFDSyxFQUFFLENBQUNJLElBQUksQ0FBQ2tCLEVBQUU7b0JBQUVFLE9BQU87b0JBQUdDLFdBQVcsSUFBRTlCLE1BQU1NLE1BQU07Z0JBQUE7WUFDekUsT0FDSztnQkFDREcsSUFBSSxDQUFDbUIsT0FBTyxDQUFDQyxLQUFLO2dCQUNsQnBCLElBQUksQ0FBQ21CLE9BQU8sQ0FBQ0UsU0FBUyxHQUFHckIsSUFBSSxDQUFDbUIsT0FBTyxDQUFDQyxLQUFLLEdBQUM3QixNQUFNTSxNQUFNO1lBQzVEO1FBQ0o7SUFDSjtJQUVBLE9BQU9HLEtBQUtVLElBQUksQ0FBQyxDQUFDWSxHQUFHQztRQUNqQixNQUFNQyxRQUFRQyxLQUFLQyxLQUFLLENBQUNKLEVBQUVELFNBQVMsR0FBRztRQUN2QyxNQUFNTSxRQUFRRixLQUFLQyxLQUFLLENBQUNILEVBQUVGLFNBQVMsR0FBRztRQUN2QyxJQUFJRyxVQUFVRyxPQUFPO1lBQ2pCLE9BQU9MLEVBQUVuQixHQUFHLEdBQUdvQixFQUFFcEIsR0FBRyxHQUFHLElBQUksQ0FBQztRQUNoQztRQUNBLE9BQVFzQixLQUFLQyxLQUFLLENBQUNILEVBQUVGLFNBQVMsR0FBRyxPQUFPSSxLQUFLQyxLQUFLLENBQUNKLEVBQUVELFNBQVMsR0FBRztJQUNyRTtBQUNKO0FBRU8sU0FBU08sZUFBZXJDLEtBQXFCLEVBQUVZLEdBQVc7SUFDN0QsSUFBSVQsV0FBb0IsQ0FBQztJQUN6QixNQUFNbUMsY0FBYzFCLFFBQVEsS0FBS1osUUFBUUEsTUFBTWtCLE1BQU0sQ0FBQyxDQUFDWCxPQUFTQSxLQUFLRSxJQUFJLENBQUNDLE9BQU8sQ0FBQ0UsU0FBUyxDQUFDO0lBRTVGLElBQUssSUFBSVAsSUFBSSxHQUFHQSxJQUFJaUMsWUFBWWhDLE1BQU0sRUFBRUQsSUFBSztRQUN6QyxNQUFNRSxPQUFPK0IsV0FBVyxDQUFDakMsRUFBRTtRQUMzQixJQUFJTyxPQUFPVCxVQUFVO2dCQUNPSTtZQUF4QkosUUFBUSxDQUFDUyxJQUFJLENBQUNDLE1BQU0sSUFBSU4sQ0FBQUEsZUFBQUEsS0FBS00sTUFBTSxjQUFYTiwwQkFBQUEsZUFBZTtnQkFDaEJBO1lBQXZCSixRQUFRLENBQUNTLElBQUksQ0FBQ0UsS0FBSyxJQUFJUCxDQUFBQSxjQUFBQSxLQUFLTyxLQUFLLGNBQVZQLHlCQUFBQSxjQUFjO1FBQ3pDLE9BQ0s7Z0JBRVdBLGVBQ0RBO1lBRlhKLFFBQVEsQ0FBQ1MsSUFBSSxHQUFHO2dCQUNaQyxRQUFRTixDQUFBQSxnQkFBQUEsS0FBS00sTUFBTSxjQUFYTiwyQkFBQUEsZ0JBQWU7Z0JBQ3ZCTyxPQUFPUCxDQUFBQSxlQUFBQSxLQUFLTyxLQUFLLGNBQVZQLDBCQUFBQSxlQUFjO2dCQUNyQlEsU0FBUyxDQUFDO1lBQ2Q7UUFDSjtJQUNKO0lBQ0FaLFFBQVEsQ0FBQ1MsSUFBSSxDQUFDRyxPQUFPLEdBQUdoQixnQkFBZ0J1QyxhQUFhLEdBQUcxQjtJQUN4RCxPQUFPVDtBQUNYO0FBRU8sU0FBU29DLGdCQUFnQnZDLEtBQXFCO1FBQUV3QyxVQUFBQSxpRUFBbUI7SUFDdEUsSUFBSXJDLFdBQW9CLENBQUM7SUFFekIsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlMLE1BQU1NLE1BQU0sRUFBRUQsSUFBSztRQUNuQyxNQUFNRSxPQUFPUCxLQUFLLENBQUNLLEVBQUU7UUFDckIsSUFBSW9DLFVBQVVsQyxLQUFLbUMsSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQztRQUMzQyxJQUFJSCxTQUFTO1lBQ1RDLFVBQVVBLFFBQVFHLEtBQUssQ0FBQ0gsUUFBUS9CLE9BQU8sQ0FBQyxPQUFLO1FBQ2pEO1FBRUEsSUFBSStCLFdBQVd0QyxVQUFVO2dCQUNPSTtZQUE1QkosUUFBUSxDQUFDc0MsUUFBUSxDQUFDNUIsTUFBTSxJQUFJTixDQUFBQSxlQUFBQSxLQUFLTSxNQUFNLGNBQVhOLDBCQUFBQSxlQUFlO2dCQUNoQkE7WUFBM0JKLFFBQVEsQ0FBQ3NDLFFBQVEsQ0FBQzNCLEtBQUssSUFBSVAsQ0FBQUEsY0FBQUEsS0FBS08sS0FBSyxjQUFWUCx5QkFBQUEsY0FBYztRQUM3QyxPQUNLO2dCQUVXQSxlQUNEQTtZQUZYSixRQUFRLENBQUNzQyxRQUFRLEdBQUc7Z0JBQ2hCNUIsUUFBUU4sQ0FBQUEsZ0JBQUFBLEtBQUtNLE1BQU0sY0FBWE4sMkJBQUFBLGdCQUFlO2dCQUN2Qk8sT0FBT1AsQ0FBQUEsZUFBQUEsS0FBS08sS0FBSyxjQUFWUCwwQkFBQUEsZUFBYztnQkFDckJRLFNBQVMsQ0FBQztZQUNkO1FBQ0o7SUFDSjtJQUNBLE9BQU9aO0FBQ1g7QUFFTyxTQUFTMEMsb0JBQW9CQyxPQUF1QjtJQUN2RCxJQUFJQyxvQkFBb0JELFFBQVFFLFlBQVksR0FBRyxtQkFBbUI7SUFDbEUsT0FBT0YsUUFBUUcsS0FBSyxDQUFDTixrQkFBa0IsS0FBSyxRQUFRRyxRQUFRSSxHQUFHLENBQUNQLGtCQUFrQixLQUFLSTtBQUMzRjtBQUVPLFNBQVNJLGVBQWVDLFFBQTBCO0lBQ3JELE1BQU1DLGNBQThCRCxTQUFTRSxNQUFNLENBQUMsQ0FBQ0MsUUFBUUM7UUFDekQsT0FBTztZQUFDLEdBQUdELE1BQU07WUFDYk4sT0FBT08sT0FBT1AsS0FBSyxHQUFHTSxPQUFPTixLQUFLLEdBQUdPLE9BQU9QLEtBQUssR0FBR00sT0FBT04sS0FBSztZQUNoRUMsS0FBS00sT0FBT1AsS0FBSyxHQUFHTSxPQUFPTixLQUFLLEdBQUdPLE9BQU9QLEtBQUssR0FBR00sT0FBT04sS0FBSztZQUM5RGpELE9BQU87bUJBQUl1RCxPQUFPdkQsS0FBSzttQkFBS3dELE9BQU94RCxLQUFLO2FBQUM7WUFDekNnRCxjQUFjO1FBQUk7SUFDeEI7SUFFQUssWUFBWXJELEtBQUssQ0FBQ21CLElBQUksQ0FBQyxDQUFDWSxHQUFpQkM7UUFBcUIsT0FBT0QsRUFBRVcsSUFBSSxDQUFDZSxPQUFPLE9BQU96QixFQUFFVSxJQUFJLENBQUNlLE9BQU8sS0FBSyxJQUFLMUIsRUFBRVcsSUFBSSxDQUFDZSxPQUFPLEtBQUt6QixFQUFFVSxJQUFJLENBQUNlLE9BQU8sS0FBSyxJQUFJLENBQUM7SUFBRztJQUNsSyxPQUFPSjtBQUNYO0FBRU8sU0FBU0ssZUFBZUMsS0FBYTtJQUN4QyxNQUFNQyxTQUFTLElBQUlDLE9BQU87SUFDMUIsTUFBTUMsT0FBT0YsT0FBT0UsSUFBSSxDQUFDSCxNQUFNSSxXQUFXO0lBQzFDLE9BQU9EO0FBQ1g7QUFFTyxTQUFTRSxtQkFBbUJMLEtBQWE7SUFDNUMsTUFBTUMsU0FBUyxJQUFJQyxPQUFPO0lBQzFCLE1BQU1DLE9BQU9GLE9BQU9FLElBQUksQ0FBQ0gsTUFBTUksV0FBVztJQUMxQyxPQUFPRDtBQUNYO0FBRU8sU0FBU0csb0JBQW9CTixLQUFhO0lBQzdDLE1BQU1DLFNBQVMsSUFBSUMsT0FBTztJQUMxQixNQUFNQyxPQUFPRixPQUFPRSxJQUFJLENBQUNILE1BQU1JLFdBQVc7SUFDMUMsT0FBT0Q7QUFDWDtBQUVPLFNBQVNJLGtCQUFrQlAsS0FBYTtJQUMzQyxNQUFNQyxTQUFTLElBQUlDLE9BQU87SUFDMUIsTUFBTUMsT0FBT0YsT0FBT0UsSUFBSSxDQUFDSCxNQUFNSSxXQUFXO0lBQzFDLE9BQU9EO0FBQ1g7QUFFTyxTQUFTSyxhQUFhUixLQUFhO0lBQ3RDLDhDQUE4QztJQUM5QyxNQUFNUyxVQUFVVCxNQUFNSSxXQUFXLEdBQUdNLEtBQUssQ0FBQztJQUMxQyxPQUFPRCxVQUFVQSxPQUFPLENBQUMsRUFBRSxHQUFHO0FBQ2xDO0FBRU8sU0FBU0UsaUJBQWlCWCxLQUFhO0lBQzFDLE1BQU1TLFVBQVVULE1BQU1JLFdBQVcsR0FBR00sS0FBSyxDQUFDO0lBQzFDLE9BQU9ELFVBQVVBLE9BQU8sQ0FBQyxFQUFFLEdBQUc7QUFDbEM7QUFFTyxTQUFTRyxrQkFBa0JaLEtBQWE7SUFDM0MsTUFBTVMsVUFBVVQsTUFBTUksV0FBVyxHQUFHTSxLQUFLLENBQUM7SUFDMUMsT0FBT0QsVUFBVUEsT0FBTyxDQUFDLEVBQUUsR0FBRztBQUNsQztBQUVPLFNBQVNJLGdCQUFnQmIsS0FBYTtJQUN6QyxNQUFNUyxVQUFVVCxNQUFNSSxXQUFXLEdBQUdNLEtBQUssQ0FBQztJQUMxQyxPQUFPRCxVQUFVQSxPQUFPLENBQUMsRUFBRSxHQUFHO0FBQ2xDO0FBRU8sU0FBU0ssbUJBQW1CZCxLQUFhO0lBQzVDLElBQUlNLG9CQUFvQk4sUUFBUTtRQUM1QixPQUFPWSxrQkFBa0JaLE9BQU9lLElBQUk7SUFDeEM7SUFFQSxJQUFJaEIsZUFBZUMsUUFBUTtRQUN2QixPQUFPUSxhQUFhUixPQUFPZSxJQUFJO0lBQ25DO0lBRUEsSUFBSVYsbUJBQW1CTCxRQUFRO1FBQzNCLE9BQU9XLGlCQUFpQlgsT0FBT2UsSUFBSTtJQUN2QztJQUVBLElBQUlSLGtCQUFrQlAsUUFBUTtRQUMxQixPQUFPYSxnQkFBZ0JiLE9BQU9lLElBQUk7SUFDdEM7SUFFQSxPQUFPZixNQUFNZSxJQUFJO0FBQ3JCO0FBRU8sU0FBU0MsV0FBV0MsT0FBeUIsRUFBRUMsT0FBaUI7SUFDbkUsTUFBTUMsZ0JBQWdCO1dBQUlGO0tBQVE7SUFDbEMsSUFBSyxJQUFJdkUsSUFBSSxHQUFHQSxJQUFJeUUsY0FBY3hFLE1BQU0sRUFBRUQsSUFBSztRQUMzQyxNQUFNbUQsU0FBU3NCLGFBQWEsQ0FBQ3pFLEVBQUU7UUFDL0IsSUFBSyxJQUFJc0IsSUFBSSxHQUFHQSxJQUFJNkIsT0FBT3hELEtBQUssQ0FBQ00sTUFBTSxFQUFFcUIsSUFBSztZQUMxQyxNQUFNcEIsT0FBT2lELE9BQU94RCxLQUFLLENBQUMyQixFQUFFO1lBQzVCLE1BQU1vRCxLQUFLTixtQkFBbUJsRSxLQUFLb0QsS0FBSztZQUN4QyxJQUFJa0IsT0FBTyxDQUFDRSxHQUFHLEVBQUU7Z0JBQ2J4RSxLQUFLRSxJQUFJLEdBQUdvRSxPQUFPLENBQUNFLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDO1lBQ2xDO1FBQ0o7SUFDSjtJQUNBLE9BQU9GO0FBQ1g7QUFZTyxTQUFTRyxxQkFBcUJDLGVBQStCO0lBQ2hFLE1BQU1DLE9BQU87SUFDYixNQUFNQyxnQkFBNEIsRUFBRTtJQUVwQyxJQUFJQyxTQUFTSCxnQkFBZ0JoRSxNQUFNLENBQUMsQ0FBQ1gsT0FBU0EsS0FBSytFLFVBQVUsR0FBRyxHQUFHQyxHQUFHLENBQUMsQ0FBQ2hGLE9BQVNBLEtBQUtpRixPQUFPLEVBQUVyRSxJQUFJLENBQUMsQ0FBQ1ksR0FBRUMsSUFBTUQsSUFBRUM7SUFDL0csSUFBSXlELFVBQVVDLHVCQUF1Qkw7SUFDckNJLFFBQVFILFVBQVUsR0FBRztJQUNyQkYsY0FBY25FLElBQUksQ0FBQ3dFO0lBRW5CLElBQUssSUFBSXBGLElBQUksR0FBR0EsS0FBSyxJQUFJQSxLQUFHOEUsS0FBTTtRQUM5QixJQUFJRSxTQUFTSCxnQkFBZ0JoRSxNQUFNLENBQUMsQ0FBQ1gsT0FBU0EsS0FBSytFLFVBQVUsSUFBS2pGLElBQUUsS0FBTUUsS0FBSytFLFVBQVUsR0FBSWpGLElBQUUsR0FBSWtGLEdBQUcsQ0FBQyxDQUFDaEYsT0FBU0EsS0FBS2lGLE9BQU8sRUFBRXJFLElBQUksQ0FBQyxDQUFDWSxHQUFFQyxJQUFNRCxJQUFFQztRQUMvSSxNQUFNeUQsVUFBVUMsdUJBQXVCTDtRQUN2Q0ksUUFBUUgsVUFBVSxHQUFHakY7UUFDckIrRSxjQUFjbkUsSUFBSSxDQUFDd0U7SUFDdkI7SUFFQUosU0FBU0gsZ0JBQWdCaEUsTUFBTSxDQUFDLENBQUNYLE9BQVNBLEtBQUsrRSxVQUFVLElBQUksSUFBSUMsR0FBRyxDQUFDLENBQUNoRixPQUFTQSxLQUFLaUYsT0FBTyxFQUFFckUsSUFBSSxDQUFDLENBQUNZLEdBQUVDLElBQU1ELElBQUVDO0lBQzdHeUQsVUFBVUMsdUJBQXVCTDtJQUNqQ0ksUUFBUUgsVUFBVSxHQUFHO0lBQ3JCRixjQUFjbkUsSUFBSSxDQUFDd0U7SUFFbkIsT0FBT0w7QUFDWDtBQUVPLFNBQVNNLHVCQUF1QkMsSUFBYztJQUVqRCxJQUFJQSxLQUFLckYsTUFBTSxLQUFLLEdBQUc7UUFDbkIsT0FBTztZQUNIZ0YsWUFBWU07WUFDWkMsZUFBZUQ7WUFDZkUsZUFBZUY7WUFDZkcsU0FBU0g7WUFDVEksTUFBTUo7WUFDTkssU0FBU0w7WUFDVE0sU0FBU047UUFDYjtJQUNKO0lBRUEsTUFBTU8sbUJBQW1CakUsS0FBS2tFLEdBQUcsQ0FBQyxHQUFHLENBQUVULEtBQUtyRixNQUFNLEdBQUcsS0FBSyxJQUFJO0lBQzlELE1BQU0rRixtQkFBbUJuRSxLQUFLa0UsR0FBRyxDQUFDLEdBQUcsQ0FBRSxJQUFJVCxLQUFLckYsTUFBTSxHQUFHLEtBQUssSUFBSTtJQUVsRSxJQUFJeUY7SUFDSixJQUFJSixLQUFLckYsTUFBTSxHQUFHLE1BQU0sS0FBS3FGLEtBQUtyRixNQUFNLEdBQUcsR0FBRztRQUMxQyxNQUFNZ0csV0FBVyxLQUFPaEcsTUFBTSxHQUFJLElBQUs7UUFDdkMsTUFBTWlHLFdBQVcsS0FBT2pHLE1BQU0sR0FBSSxJQUFLO1FBQ3ZDeUYsVUFBVSxDQUFDSixJQUFJLENBQUNXLFNBQVMsR0FBR1gsSUFBSSxDQUFDWSxTQUFTLElBQUk7SUFDbEQsT0FDSztRQUNGLE1BQU0vRixNQUFNMEIsS0FBS2tFLEdBQUcsQ0FBQyxHQUFHLENBQUVULEtBQUtyRixNQUFNLEdBQUcsS0FBSyxJQUFJO1FBQ2pEeUYsVUFBVUosSUFBSSxDQUFDbkYsSUFBSTtJQUN0QjtJQUVBLElBQUl3RixPQUFlO0lBQ25CQSxPQUFPTCxLQUFLckMsTUFBTSxDQUFDLENBQUN2QixHQUFHQyxJQUFNRCxJQUFHQztJQUNoQ2dFLE9BQU9BLE9BQU9MLEtBQUtyRixNQUFNO0lBRXpCLE9BQU87UUFDSGdGLFlBQVlNO1FBQ1pDLGVBQWVXLHFCQUFxQkwsa0JBQWtCUjtRQUN0REcsZUFBZVUscUJBQXFCSCxrQkFBa0JWO1FBQ3RESSxTQUFTQTtRQUNUQyxNQUFNQTtRQUNOQyxTQUFTTixJQUFJLENBQUMsRUFBRTtRQUNoQk8sU0FBU1AsSUFBSSxDQUFDQSxLQUFLckYsTUFBTSxHQUFHLEVBQUU7SUFDbEM7QUFDSjtBQUVPLFNBQVNrRyxxQkFBcUJDLFdBQW1CLEVBQUVkLElBQWM7SUFDcEUsSUFBSWUsT0FBT0MsU0FBUyxDQUFDRixjQUFjO1FBQy9CLE9BQU9kLElBQUksQ0FBQ2MsWUFBWTtJQUM1QjtJQUVBLE1BQU1ILFdBQVdwRSxLQUFLMEUsSUFBSSxDQUFDSDtJQUMzQixNQUFNRixXQUFXckUsS0FBS0MsS0FBSyxDQUFDc0U7SUFFNUIsSUFBSUksU0FBUztJQUNiLElBQUlDLFNBQVM7SUFFYixJQUFJTCxjQUFjSCxhQUFhLE1BQU07UUFDakNPLFNBQVM7SUFDYixPQUNLLElBQUlKLGNBQWNILGFBQWEsTUFBTTtRQUN0Q1EsU0FBUztJQUNiO0lBQ0EsNkNBQTZDO0lBQ3pDLHdCQUF3QjtJQUU1QixPQUFRLENBQUNuQixJQUFJLENBQUNXLFNBQVMsR0FBR08sU0FBU2xCLElBQUksQ0FBQ1ksU0FBUyxHQUFHTyxNQUFLLElBQU1ELENBQUFBLFNBQVNDLE1BQUs7QUFDakYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9EYXRhL0JhbmsudHM/NjcyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdGFydCB9IGZyb20gXCJyZXBsXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElBY2NvdW50TGluZSB7XHJcbiAgICBkYXRlOiBEYXRlO1xyXG4gICAgcGN0SW5Nb250aDogbnVtYmVyOyAvLyBtYXAgMS0yOC8yOS8zMC8zMSBtb250aCB0byAxLTEwMCVcclxuICAgIGRlYml0OiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBjcmVkaXQ6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIGxhYmVsOiBzdHJpbmc7XHJcbiAgICBiYWxhbmNlOiBudW1iZXI7XHJcbiAgICB0YWdzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJQWNjb3VudExpbmVzIHtcclxuICAgIGxpbmVzOiBJQWNjb3VudExpbmVbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJQWNjb3VudFBlcmlvZCB7XHJcbiAgICBiZWdpbjogRGF0ZTtcclxuICAgIGVuZDogRGF0ZTtcclxuICAgIGxpbmVzOiBJQWNjb3VudExpbmVbXTtcclxuICAgIGlzQWdncmVnYXRlZDogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVE1hcHBpbmcgPSB7W21hdGNoOiBzdHJpbmddOiBzdHJpbmd9XHJcbmV4cG9ydCBpbnRlcmZhY2UgSU1hcHBpbmdMaW5lIHtcclxuICAgIG1hdGNoOiBzdHJpbmc7XHJcbiAgICB0YWdzOiBzdHJpbmc7XHJcbn1cclxuZXhwb3J0IHR5cGUgVGFnTGluZSA9IHtbaWQ6IHN0cmluZ106IHtjcmVkaXQ6IG51bWJlciwgZGViaXQ6IG51bWJlciwgc3ViVGFnczogVGFnTGluZX07IH1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVRhZyB7XHJcbiAgICB0YWc6IHN0cmluZztcclxuICAgIGNvdW50OiBudW1iZXI7XHJcbiAgICBmcmVxdWVuY3k6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVEJ1ZGdldCA9IHtbdGFnOiBzdHJpbmddOiBudW1iZXJ9XHJcbmV4cG9ydCBpbnRlcmZhY2UgSVRhZ0J1ZGdldCB7XHJcbiAgICB0YWc6IHN0cmluZztcclxuICAgIGFsbG93ZWQ6IG51bWJlcjtcclxuICAgIGNvbnN1bWVkOiBudW1iZXI7XHJcbiAgICBsaW5lczogSUFjY291bnRMaW5lW107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUJ1ZGdldExpbmUge1xyXG4gICAgdGFnOiBzdHJpbmc7XHJcbiAgICBhbW91bnQ6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGVudW0gRURvY3VtZW50VHlwZSB7XHJcbiAgICBBQ0NPVU5UID0gXCJBQ0NPVU5UXCIsXHJcbiAgICBNQVBQSU5HID0gXCJNQVBQSU5HXCIsXHJcbiAgICBCVURHRVQgID0gXCJCVURHRVRcIixcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFnZ3JlZ2F0ZUJ5VGFncyhsaW5lczogSUFjY291bnRMaW5lW10sIHRhZ0xldmVsOiBudW1iZXIsIGV4Y2x1ZGVUYWc6IHN0cmluZyk6IFRhZ0xpbmUge1xyXG4gICAgbGV0IGFncmVnYXRlOiBUYWdMaW5lID0ge307XHJcbiAgICBsZXQgaXNSZWN1cnNpdmUgPSB0YWdMZXZlbCA8IDA7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcclxuXHJcbiAgICAgICAgbGV0IGlkeCA9IGV4Y2x1ZGVUYWcgPT09IFwiXCIgPyAwIDogbGluZS50YWdzLmluZGV4T2YoZXhjbHVkZVRhZyk7XHJcbiAgICAgICAgbGV0IGxldmVsID0gaXNSZWN1cnNpdmUgPyAoaWR4ICUgbGluZS50YWdzLmxlbmd0aCkgOiB0YWdMZXZlbDtcclxuICAgICAgICBsZXQgdGFnID0gbGluZS50YWdzW2xldmVsXTtcclxuXHJcbiAgICAgICAgaWYgKHRhZyA9PT0gZXhjbHVkZVRhZyAmJiBsZXZlbCA8IChsaW5lLnRhZ3MubGVuZ3RoIC0gMSkpIHtcclxuICAgICAgICAgICAgdGFnID0gbGluZS50YWdzW2xldmVsICsgMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gZXhjbHVkZVRhZyAmJiBsZXZlbCA9PT0gKGxpbmUudGFncy5sZW5ndGggLSAxKSkge1xyXG4gICAgICAgICAgICB0YWcgPSBpc1JlY3Vyc2l2ZSA/IGxpbmUudGFnc1swXSA6IFwiVW5kZWZpbmVkXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGFnIGluIGFncmVnYXRlKSB7XHJcbiAgICAgICAgICAgIGFncmVnYXRlW3RhZ10uY3JlZGl0ICs9IGxpbmUuY3JlZGl0ID8/IDA7XHJcbiAgICAgICAgICAgIGFncmVnYXRlW3RhZ10uZGViaXQgKz0gbGluZS5kZWJpdCA/PyAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWdyZWdhdGVbdGFnXSA9IHtcclxuICAgICAgICAgICAgICAgIGNyZWRpdDogbGluZS5jcmVkaXQgPz8gMCxcclxuICAgICAgICAgICAgICAgIGRlYml0OiBsaW5lLmRlYml0ID8/IDAsXHJcbiAgICAgICAgICAgICAgICBzdWJUYWdzOiB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhZ3JlZ2F0ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUYWdzKGxpbmVzOiBJQWNjb3VudExpbmVbXSk6IHN0cmluZ1tdIHtcclxuICAgIGxldCB0YWdzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRhZ3MucHVzaCguLi5saW5lc1tpXS50YWdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlc1xyXG4gICAgdGFncyA9IHRhZ3MuZmlsdGVyKGZ1bmN0aW9uKHRhZywgaWR4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRhZ3MuaW5kZXhPZih0YWcpID09PSBpZHg7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGFncy5zb3J0KCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VGFnc1dpdGhDb3VudChsaW5lczogSUFjY291bnRMaW5lW10sIHN0YXJ0aW5nVGFnOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBJVGFnW10ge1xyXG4gICAgbGV0IHRhZ3M6IElUYWdbXSA9IFtdO1xyXG5cclxuICAgIGRlYnVnZ2VyO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBzdGFydElkeCA9IDA7XHJcbiAgICAgICAgbGV0IGVuZElkeCA9IGxpbmVzW2ldLnRhZ3MubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoc3RhcnRpbmdUYWcpIHtcclxuICAgICAgICAgICAgLy8gQ29uc2lkZXIgb25seSB0aGUgbmV4dCBhZnRlciB0aGUgc3RhcnRpbmdUYWdcclxuICAgICAgICAgICAgY29uc3QgaWR4ID0gbGluZXNbaV0udGFncy5maW5kSW5kZXgoKHRhZykgPT4gdGFnID09PSBzdGFydGluZ1RhZyk7XHJcbiAgICAgICAgICAgIGlmIChpZHggPT09IChsaW5lc1tpXS50YWdzLmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAvL0lnbm9yZVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBzdGFydGluZ1RhZyBpcyB0aGUgbGFzdCBvbmUgaW4gdGhlIHRhZyBsaXN0LCBjb25zaWRlciB0aGUgZmlyc3QgdGFnIG9mIHRoZSBsaXN0IGluc3RlYWRcclxuICAgICAgICAgICAgICAgIC8vc3RhcnRJZHggPSAwO1xyXG4gICAgICAgICAgICAgICAgLy9lbmRJZHggPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzdGFydElkeCA9IGlkeCArIDE7XHJcbiAgICAgICAgICAgIGVuZElkeCA9IGlkeCArIDI7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3RhcnRpbmcgdGFnIGlkeCBcIiArIHN0YXJ0SWR4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGogPSBzdGFydElkeDsgaiA8IGVuZElkeDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICBpZihsaW5lc1tpXS50YWdzW2pdID09PSBzdGFydGluZ1RhZykge1xyXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRhZ0lkeCA9IHRhZ3MuZmluZEluZGV4KCh0YWcpID0+IHRhZy50YWcgPT09IGxpbmVzW2ldLnRhZ3Nbal0pO1xyXG4gICAgICAgICAgICBpZiAodGFnSWR4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGFncy5wdXNoKHt0YWc6IGxpbmVzW2ldLnRhZ3Nbal0sIGNvdW50OiAxLCBmcmVxdWVuY3k6IDEvbGluZXMubGVuZ3RofSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0YWdzW3RhZ0lkeF0uY291bnQrKztcclxuICAgICAgICAgICAgICAgIHRhZ3NbdGFnSWR4XS5mcmVxdWVuY3kgPSB0YWdzW3RhZ0lkeF0uY291bnQvbGluZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YWdzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICBjb25zdCBmcmVxQSA9IE1hdGguZmxvb3IoYS5mcmVxdWVuY3kgKiAxMDApO1xyXG4gICAgICAgIGNvbnN0IGZyZXFCID0gTWF0aC5mbG9vcihiLmZyZXF1ZW5jeSAqIDEwMCk7XHJcbiAgICAgICAgaWYgKGZyZXFBID09PSBmcmVxQikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS50YWcgPiBiLnRhZyA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChNYXRoLmZsb29yKGIuZnJlcXVlbmN5ICogMTAwKSAtIE1hdGguZmxvb3IoYS5mcmVxdWVuY3kgKiAxMDApKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWdncmVnYXRlQnlUYWcobGluZXM6IElBY2NvdW50TGluZVtdLCB0YWc6IHN0cmluZyk6IFRhZ0xpbmUge1xyXG4gICAgbGV0IGFncmVnYXRlOiBUYWdMaW5lID0ge307XHJcbiAgICBjb25zdCB0YWdnZWRMaW5lcyA9IHRhZyA9PT0gXCJcIiA/IGxpbmVzIDogbGluZXMuZmlsdGVyKChsaW5lKSA9PiBsaW5lLnRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWdnZWRMaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGxpbmUgPSB0YWdnZWRMaW5lc1tpXTtcclxuICAgICAgICBpZiAodGFnIGluIGFncmVnYXRlKSB7XHJcbiAgICAgICAgICAgIGFncmVnYXRlW3RhZ10uY3JlZGl0ICs9IGxpbmUuY3JlZGl0ID8/IDA7XHJcbiAgICAgICAgICAgIGFncmVnYXRlW3RhZ10uZGViaXQgKz0gbGluZS5kZWJpdCA/PyAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWdyZWdhdGVbdGFnXSA9IHtcclxuICAgICAgICAgICAgICAgIGNyZWRpdDogbGluZS5jcmVkaXQgPz8gMCxcclxuICAgICAgICAgICAgICAgIGRlYml0OiBsaW5lLmRlYml0ID8/IDAsXHJcbiAgICAgICAgICAgICAgICBzdWJUYWdzOiB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWdyZWdhdGVbdGFnXS5zdWJUYWdzID0gYWdncmVnYXRlQnlUYWdzKHRhZ2dlZExpbmVzLCAwLCB0YWcpO1xyXG4gICAgcmV0dXJuIGFncmVnYXRlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWdncmVnYXRlQnlEYXRlKGxpbmVzOiBJQWNjb3VudExpbmVbXSwgbW9udGhseTogYm9vbGVhbiA9IGZhbHNlKTogVGFnTGluZSB7XHJcbiAgICBsZXQgYWdyZWdhdGU6IFRhZ0xpbmUgPSB7fTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgICAgIGxldCBzdHJEYXRlID0gbGluZS5kYXRlLnRvTG9jYWxlRGF0ZVN0cmluZyhcImZyLUZSXCIpO1xyXG4gICAgICAgIGlmIChtb250aGx5KSB7XHJcbiAgICAgICAgICAgIHN0ckRhdGUgPSBzdHJEYXRlLnNsaWNlKHN0ckRhdGUuaW5kZXhPZihcIi9cIikrMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdHJEYXRlIGluIGFncmVnYXRlKSB7XHJcbiAgICAgICAgICAgIGFncmVnYXRlW3N0ckRhdGVdLmNyZWRpdCArPSBsaW5lLmNyZWRpdCA/PyAwO1xyXG4gICAgICAgICAgICBhZ3JlZ2F0ZVtzdHJEYXRlXS5kZWJpdCArPSBsaW5lLmRlYml0ID8/IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhZ3JlZ2F0ZVtzdHJEYXRlXSA9IHtcclxuICAgICAgICAgICAgICAgIGNyZWRpdDogbGluZS5jcmVkaXQgPz8gMCxcclxuICAgICAgICAgICAgICAgIGRlYml0OiBsaW5lLmRlYml0ID8/IDAsXHJcbiAgICAgICAgICAgICAgICBzdWJUYWdzOiB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFncmVnYXRlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWNjb3VudFBlcmlvZFN0cihhY2NvdW50OiBJQWNjb3VudFBlcmlvZCk6IHN0cmluZyB7XHJcbiAgICBsZXQgYWdncmVnYXRlZE1lbnRpb24gPSBhY2NvdW50LmlzQWdncmVnYXRlZCA/IFwiIChBZ2dyZWdhdGVkKSBcIiA6IFwiXCI7XHJcbiAgICByZXR1cm4gYWNjb3VudC5iZWdpbi50b0xvY2FsZURhdGVTdHJpbmcoKSArIFwiIC0gXCIgKyBhY2NvdW50LmVuZC50b0xvY2FsZURhdGVTdHJpbmcoKSArIGFnZ3JlZ2F0ZWRNZW50aW9uO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2hvbGVQZXJpb2QoYWNjb3VudHM6IElBY2NvdW50UGVyaW9kW10pOiBJQWNjb3VudFBlcmlvZCB7XHJcbiAgICBjb25zdCB3aG9sZVBlcmlvZDogSUFjY291bnRQZXJpb2QgPSBhY2NvdW50cy5yZWR1Y2UoKHJlc3VsdCwgcGVyaW9kKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHsuLi5yZXN1bHQsXHJcbiAgICAgICAgICAgIGJlZ2luOiBwZXJpb2QuYmVnaW4gPCByZXN1bHQuYmVnaW4gPyBwZXJpb2QuYmVnaW4gOiByZXN1bHQuYmVnaW4sXHJcbiAgICAgICAgICAgIGVuZDogcGVyaW9kLmJlZ2luID4gcmVzdWx0LmJlZ2luID8gcGVyaW9kLmJlZ2luIDogcmVzdWx0LmJlZ2luLFxyXG4gICAgICAgICAgICBsaW5lczogWy4uLnJlc3VsdC5saW5lcywgLi4ucGVyaW9kLmxpbmVzXSxcclxuICAgICAgICAgICAgaXNBZ2dyZWdhdGVkOiB0cnVlfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHdob2xlUGVyaW9kLmxpbmVzLnNvcnQoKGE6IElBY2NvdW50TGluZSwgYjogSUFjY291bnRMaW5lKSA9PiB7cmV0dXJuIGEuZGF0ZS5nZXRUaW1lKCkgPT09IGIuZGF0ZS5nZXRUaW1lKCkgPyAwIDogKGEuZGF0ZS5nZXRUaW1lKCkgPiBiLmRhdGUuZ2V0VGltZSgpID8gMSA6IC0xKTt9KTtcclxuICAgIHJldHVybiB3aG9sZVBlcmlvZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF5bWVudExhYmVsKGxhYmVsOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHJlZ0V4cCA9IG5ldyBSZWdFeHAoLyhQQUlFTUVOVFxccykvKTtcclxuICAgIGNvbnN0IHRlc3QgPSByZWdFeHAudGVzdChsYWJlbC50b1VwcGVyQ2FzZSgpKTtcclxuICAgIHJldHVybiB0ZXN0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNEaXJlY3REZWJpdExhYmVsKGxhYmVsOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHJlZ0V4cCA9IG5ldyBSZWdFeHAoLyhQUkxWXFxzU0VQQVxccykvKTtcclxuICAgIGNvbnN0IHRlc3QgPSByZWdFeHAudGVzdChsYWJlbC50b1VwcGVyQ2FzZSgpKTtcclxuICAgIHJldHVybiB0ZXN0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNCYW5rVHJhbnNmZXJMYWJlbChsYWJlbDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKC8oVklSXFxzKS8pO1xyXG4gICAgY29uc3QgdGVzdCA9IHJlZ0V4cC50ZXN0KGxhYmVsLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgcmV0dXJuIHRlc3Q7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1dpdGhkcmF3YWxMYWJlbChsYWJlbDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKC8oUkVUUkFJVFxcc0RBQlxccykvKTtcclxuICAgIGNvbnN0IHRlc3QgPSByZWdFeHAudGVzdChsYWJlbC50b1VwcGVyQ2FzZSgpKTtcclxuICAgIHJldHVybiB0ZXN0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF5bWVudElkKGxhYmVsOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgLy9QQUlFTUVOVCBDQiAzMDA3IEZSIExZT04gTEEtQkFSR0UgQ0FSVEUgMjE3OFxyXG4gICAgY29uc3QgbWF0Y2hlcyA9IGxhYmVsLnRvVXBwZXJDYXNlKCkubWF0Y2goLyg/OlBBSUVNRU5UXFxzKD86Q0J8UFNDKVxcc1xcZFxcZFxcZFxcZFxccykoKFthLXpBLVpdfC18X3xcXGQrfFxcL3xcXCp8XFxzKSspKD86Q0FSVEVcXHNcXGRcXGRcXGRcXGQpLyk7XHJcbiAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiBcIlwiO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlyZWN0RGViaXRJZChsYWJlbDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IG1hdGNoZXMgPSBsYWJlbC50b1VwcGVyQ2FzZSgpLm1hdGNoKC8oPzpQUkxWXFxzU0VQQVxccykoKFthLXpBLVpdfC18X3xcXHMpKykvKTtcclxuICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6IFwiXCI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCYW5rVHJhbnNmZXJJZChsYWJlbDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IG1hdGNoZXMgPSBsYWJlbC50b1VwcGVyQ2FzZSgpLm1hdGNoKC8oPzpWSVJcXHMpKChbYS16QS1aXXwtfF98XFxzKSspLyk7XHJcbiAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiBcIlwiO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2l0aGRyYXdhbElkKGxhYmVsOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgbWF0Y2hlcyA9IGxhYmVsLnRvVXBwZXJDYXNlKCkubWF0Y2goL1JFVFJBSVQgREFCLyk7XHJcbiAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMF0gOiBcIlwiO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdElkRnJvbUxhYmVsKGxhYmVsOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgaWYgKGlzQmFua1RyYW5zZmVyTGFiZWwobGFiZWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEJhbmtUcmFuc2ZlcklkKGxhYmVsKS50cmltKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzUGF5bWVudExhYmVsKGxhYmVsKSkge1xyXG4gICAgICAgIHJldHVybiBnZXRQYXltZW50SWQobGFiZWwpLnRyaW0oKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNEaXJlY3REZWJpdExhYmVsKGxhYmVsKSkge1xyXG4gICAgICAgIHJldHVybiBnZXREaXJlY3REZWJpdElkKGxhYmVsKS50cmltKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzV2l0aGRyYXdhbExhYmVsKGxhYmVsKSkge1xyXG4gICAgICAgIHJldHVybiBnZXRXaXRoZHJhd2FsSWQobGFiZWwpLnRyaW0oKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGFiZWwudHJpbSgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGFnUGVyaW9kcyhwZXJpb2RzOiBJQWNjb3VudFBlcmlvZFtdLCBtYXBwaW5nOiBUTWFwcGluZyk6IElBY2NvdW50UGVyaW9kW10ge1xyXG4gICAgY29uc3QgdGFnZ2VkUGVyaW9kcyA9IFsuLi5wZXJpb2RzXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFnZ2VkUGVyaW9kcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHBlcmlvZCA9IHRhZ2dlZFBlcmlvZHNbaV07XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwZXJpb2QubGluZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbGluZSA9IHBlcmlvZC5saW5lc1tqXTtcclxuICAgICAgICAgICAgY29uc3QgaWQgPSBleHRyYWN0SWRGcm9tTGFiZWwobGluZS5sYWJlbCk7XHJcbiAgICAgICAgICAgIGlmIChtYXBwaW5nW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgbGluZS50YWdzID0gbWFwcGluZ1tpZF0uc3BsaXQoJz4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0YWdnZWRQZXJpb2RzO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElCb3hQbG90IHtcclxuICAgIHBjdEluTW9udGg6IG51bWJlcjtcclxuICAgIG1pbmltdW06IG51bWJlcjtcclxuICAgIGZpcnN0UXVhcnRpbGU6IG51bWJlcjtcclxuICAgIG1lYW46IG51bWJlcjtcclxuICAgIG1lZGlhbmU6IG51bWJlcjtcclxuICAgIHRoaXJkUXVhcnRpbGU6IG51bWJlcjtcclxuICAgIG1heGltdW06IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm94UGxvdHNGcm9tTGluZXMoYWxsQWNjb3VudExpbmVzOiBJQWNjb3VudExpbmVbXSk6IElCb3hQbG90W10ge1xyXG4gICAgY29uc3Qgc3RlcCA9IDEwO1xyXG4gICAgY29uc3QgYm94UGxvdEJ5U3RlcDogSUJveFBsb3RbXSA9IFtdO1xyXG5cclxuICAgIGxldCB2YWx1ZXMgPSBhbGxBY2NvdW50TGluZXMuZmlsdGVyKChsaW5lKSA9PiBsaW5lLnBjdEluTW9udGggPCA1KS5tYXAoKGxpbmUpID0+IGxpbmUuYmFsYW5jZSkuc29ydCgoYSxiKSA9PiBhLWIpO1xyXG4gICAgbGV0IGJveFBsb3QgPSBleHRyYWN0Qm94UGxvdEZyb21EYXRhKHZhbHVlcyk7XHJcbiAgICBib3hQbG90LnBjdEluTW9udGggPSAxO1xyXG4gICAgYm94UGxvdEJ5U3RlcC5wdXNoKGJveFBsb3QpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSA1OyBpIDw9IDk1OyBpKz1zdGVwKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlcyA9IGFsbEFjY291bnRMaW5lcy5maWx0ZXIoKGxpbmUpID0+IGxpbmUucGN0SW5Nb250aCA+PSAoaS01KSAmJiBsaW5lLnBjdEluTW9udGggPCAoaSs1KSkubWFwKChsaW5lKSA9PiBsaW5lLmJhbGFuY2UpLnNvcnQoKGEsYikgPT4gYS1iKTtcclxuICAgICAgICBjb25zdCBib3hQbG90ID0gZXh0cmFjdEJveFBsb3RGcm9tRGF0YSh2YWx1ZXMpO1xyXG4gICAgICAgIGJveFBsb3QucGN0SW5Nb250aCA9IGk7XHJcbiAgICAgICAgYm94UGxvdEJ5U3RlcC5wdXNoKGJveFBsb3QpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbHVlcyA9IGFsbEFjY291bnRMaW5lcy5maWx0ZXIoKGxpbmUpID0+IGxpbmUucGN0SW5Nb250aCA+PSA5NSkubWFwKChsaW5lKSA9PiBsaW5lLmJhbGFuY2UpLnNvcnQoKGEsYikgPT4gYS1iKTtcclxuICAgIGJveFBsb3QgPSBleHRyYWN0Qm94UGxvdEZyb21EYXRhKHZhbHVlcyk7XHJcbiAgICBib3hQbG90LnBjdEluTW9udGggPSAxMDA7XHJcbiAgICBib3hQbG90QnlTdGVwLnB1c2goYm94UGxvdCk7XHJcblxyXG4gICAgcmV0dXJuIGJveFBsb3RCeVN0ZXA7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0Qm94UGxvdEZyb21EYXRhKGRhdGE6IG51bWJlcltdKTogSUJveFBsb3Qge1xyXG5cclxuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBjdEluTW9udGg6IE5hTixcclxuICAgICAgICAgICAgZmlyc3RRdWFydGlsZTogTmFOLFxyXG4gICAgICAgICAgICB0aGlyZFF1YXJ0aWxlOiBOYU4sXHJcbiAgICAgICAgICAgIG1lZGlhbmU6IE5hTixcclxuICAgICAgICAgICAgbWVhbjogTmFOLFxyXG4gICAgICAgICAgICBtaW5pbXVtOiBOYU4sXHJcbiAgICAgICAgICAgIG1heGltdW06IE5hTlxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZmlyc3RRdWFydGlsZUlkeCA9IE1hdGgubWF4KDAsICgoZGF0YS5sZW5ndGggKyAzKSAvIDQpIC0xKTtcclxuICAgIGNvbnN0IHRoaXJkUXVhcnRpbGVJZHggPSBNYXRoLm1heCgwLCAoKDMgKiBkYXRhLmxlbmd0aCArIDEpIC8gNCkgLTEpO1xyXG5cclxuICAgIGxldCBtZWRpYW5lOiBudW1iZXI7XHJcbiAgICBpZiAoZGF0YS5sZW5ndGggJSAyID09PSAwICYmIGRhdGEubGVuZ3RoID4gMikge1xyXG4gICAgICAgIGNvbnN0IGxvd2VySWR4ID0gKChkYXRhLmxlbmd0aCkgLyAyKSAtIDI7XHJcbiAgICAgICAgY29uc3QgdXBwZXJJZHggPSAoKGRhdGEubGVuZ3RoKSAvIDIpIC0gMTtcclxuICAgICAgICBtZWRpYW5lID0gKGRhdGFbbG93ZXJJZHhdICsgZGF0YVt1cHBlcklkeF0pIC8gMjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgY29uc3QgaWR4ID0gTWF0aC5tYXgoMCwgKChkYXRhLmxlbmd0aCArIDEpIC8gMikgLTEpO1xyXG4gICAgICAgbWVkaWFuZSA9IGRhdGFbaWR4XTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbWVhbjogbnVtYmVyID0gMDtcclxuICAgIG1lYW4gPSBkYXRhLnJlZHVjZSgoYSwgYikgPT4gYSArYik7XHJcbiAgICBtZWFuID0gbWVhbiAvIGRhdGEubGVuZ3RoO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcGN0SW5Nb250aDogTmFOLFxyXG4gICAgICAgIGZpcnN0UXVhcnRpbGU6IGNvbXB1dGVRdWFydGlsZVZhbHVlKGZpcnN0UXVhcnRpbGVJZHgsIGRhdGEpLFxyXG4gICAgICAgIHRoaXJkUXVhcnRpbGU6IGNvbXB1dGVRdWFydGlsZVZhbHVlKHRoaXJkUXVhcnRpbGVJZHgsIGRhdGEpLFxyXG4gICAgICAgIG1lZGlhbmU6IG1lZGlhbmUsXHJcbiAgICAgICAgbWVhbjogbWVhbixcclxuICAgICAgICBtaW5pbXVtOiBkYXRhWzBdLFxyXG4gICAgICAgIG1heGltdW06IGRhdGFbZGF0YS5sZW5ndGggLSAxXVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVRdWFydGlsZVZhbHVlKHF1YXJ0aWxlSWR4OiBudW1iZXIsIGRhdGE6IG51bWJlcltdKTogbnVtYmVyIHtcclxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHF1YXJ0aWxlSWR4KSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhW3F1YXJ0aWxlSWR4XTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsb3dlcklkeCA9IE1hdGguY2VpbChxdWFydGlsZUlkeCk7XHJcbiAgICBjb25zdCB1cHBlcklkeCA9IE1hdGguZmxvb3IocXVhcnRpbGVJZHgpO1xyXG5cclxuICAgIGxldCBjb2VmZjEgPSAxO1xyXG4gICAgbGV0IGNvZWZmMiA9IDE7XHJcblxyXG4gICAgaWYgKHF1YXJ0aWxlSWR4IC0gbG93ZXJJZHggPT09IDAuMjUpIHtcclxuICAgICAgICBjb2VmZjEgPSAzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocXVhcnRpbGVJZHggLSBsb3dlcklkeCA9PT0gMC43NSkge1xyXG4gICAgICAgIGNvZWZmMiA9IDM7XHJcbiAgICB9XHJcbiAgICAvLyBlbHNlIHsgIChxdWFydGlsZUlkeCAtIGxvd2VySWR4ID09PSAwLjUpIHtcclxuICAgICAgICAvL2NvZWZmMSA9IDEsIGNvZWZmMiA9IDFcclxuXHJcbiAgICByZXR1cm4gIChkYXRhW2xvd2VySWR4XSAqIGNvZWZmMSArIGRhdGFbdXBwZXJJZHhdICogY29lZmYyKSAvIChjb2VmZjEgKyBjb2VmZjIpO1xyXG59Il0sIm5hbWVzIjpbIkVEb2N1bWVudFR5cGUiLCJhZ2dyZWdhdGVCeVRhZ3MiLCJsaW5lcyIsInRhZ0xldmVsIiwiZXhjbHVkZVRhZyIsImFncmVnYXRlIiwiaXNSZWN1cnNpdmUiLCJpIiwibGVuZ3RoIiwibGluZSIsImlkeCIsInRhZ3MiLCJpbmRleE9mIiwibGV2ZWwiLCJ0YWciLCJjcmVkaXQiLCJkZWJpdCIsInN1YlRhZ3MiLCJleHRyYWN0VGFncyIsInB1c2giLCJmaWx0ZXIiLCJzb3J0IiwiZXh0cmFjdFRhZ3NXaXRoQ291bnQiLCJzdGFydGluZ1RhZyIsInN0YXJ0SWR4IiwiZW5kSWR4IiwiZmluZEluZGV4IiwiY29uc29sZSIsImxvZyIsImoiLCJ0YWdJZHgiLCJjb3VudCIsImZyZXF1ZW5jeSIsImEiLCJiIiwiZnJlcUEiLCJNYXRoIiwiZmxvb3IiLCJmcmVxQiIsImFnZ3JlZ2F0ZUJ5VGFnIiwidGFnZ2VkTGluZXMiLCJhZ2dyZWdhdGVCeURhdGUiLCJtb250aGx5Iiwic3RyRGF0ZSIsImRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJzbGljZSIsImdldEFjY291bnRQZXJpb2RTdHIiLCJhY2NvdW50IiwiYWdncmVnYXRlZE1lbnRpb24iLCJpc0FnZ3JlZ2F0ZWQiLCJiZWdpbiIsImVuZCIsImdldFdob2xlUGVyaW9kIiwiYWNjb3VudHMiLCJ3aG9sZVBlcmlvZCIsInJlZHVjZSIsInJlc3VsdCIsInBlcmlvZCIsImdldFRpbWUiLCJpc1BheW1lbnRMYWJlbCIsImxhYmVsIiwicmVnRXhwIiwiUmVnRXhwIiwidGVzdCIsInRvVXBwZXJDYXNlIiwiaXNEaXJlY3REZWJpdExhYmVsIiwiaXNCYW5rVHJhbnNmZXJMYWJlbCIsImlzV2l0aGRyYXdhbExhYmVsIiwiZ2V0UGF5bWVudElkIiwibWF0Y2hlcyIsIm1hdGNoIiwiZ2V0RGlyZWN0RGViaXRJZCIsImdldEJhbmtUcmFuc2ZlcklkIiwiZ2V0V2l0aGRyYXdhbElkIiwiZXh0cmFjdElkRnJvbUxhYmVsIiwidHJpbSIsInRhZ1BlcmlvZHMiLCJwZXJpb2RzIiwibWFwcGluZyIsInRhZ2dlZFBlcmlvZHMiLCJpZCIsInNwbGl0IiwiZ2V0Qm94UGxvdHNGcm9tTGluZXMiLCJhbGxBY2NvdW50TGluZXMiLCJzdGVwIiwiYm94UGxvdEJ5U3RlcCIsInZhbHVlcyIsInBjdEluTW9udGgiLCJtYXAiLCJiYWxhbmNlIiwiYm94UGxvdCIsImV4dHJhY3RCb3hQbG90RnJvbURhdGEiLCJkYXRhIiwiTmFOIiwiZmlyc3RRdWFydGlsZSIsInRoaXJkUXVhcnRpbGUiLCJtZWRpYW5lIiwibWVhbiIsIm1pbmltdW0iLCJtYXhpbXVtIiwiZmlyc3RRdWFydGlsZUlkeCIsIm1heCIsInRoaXJkUXVhcnRpbGVJZHgiLCJsb3dlcklkeCIsInVwcGVySWR4IiwiY29tcHV0ZVF1YXJ0aWxlVmFsdWUiLCJxdWFydGlsZUlkeCIsIk51bWJlciIsImlzSW50ZWdlciIsImNlaWwiLCJjb2VmZjEiLCJjb2VmZjIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Data/Bank.ts\n"));

/***/ })

});