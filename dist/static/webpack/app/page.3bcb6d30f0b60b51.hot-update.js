"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/Data/Bank.ts":
/*!*********************************!*\
  !*** ./components/Data/Bank.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EDocumentType: function() { return /* binding */ EDocumentType; },\n/* harmony export */   aggregateByDate: function() { return /* binding */ aggregateByDate; },\n/* harmony export */   aggregateByTag: function() { return /* binding */ aggregateByTag; },\n/* harmony export */   aggregateByTags: function() { return /* binding */ aggregateByTags; },\n/* harmony export */   extractIdFromLabel: function() { return /* binding */ extractIdFromLabel; },\n/* harmony export */   extractTags: function() { return /* binding */ extractTags; },\n/* harmony export */   extractTagsWithCount: function() { return /* binding */ extractTagsWithCount; },\n/* harmony export */   getAccountPeriodStr: function() { return /* binding */ getAccountPeriodStr; },\n/* harmony export */   getBankTransferId: function() { return /* binding */ getBankTransferId; },\n/* harmony export */   getDirectDebitId: function() { return /* binding */ getDirectDebitId; },\n/* harmony export */   getPaymentId: function() { return /* binding */ getPaymentId; },\n/* harmony export */   getWholePeriod: function() { return /* binding */ getWholePeriod; },\n/* harmony export */   getWithdrawalId: function() { return /* binding */ getWithdrawalId; },\n/* harmony export */   isBankTransferLabel: function() { return /* binding */ isBankTransferLabel; },\n/* harmony export */   isDirectDebitLabel: function() { return /* binding */ isDirectDebitLabel; },\n/* harmony export */   isPaymentLabel: function() { return /* binding */ isPaymentLabel; },\n/* harmony export */   isWithdrawalLabel: function() { return /* binding */ isWithdrawalLabel; },\n/* harmony export */   tagPeriods: function() { return /* binding */ tagPeriods; }\n/* harmony export */ });\nvar EDocumentType;\n(function(EDocumentType) {\n    EDocumentType[\"ACCOUNT\"] = \"ACCOUNT\";\n    EDocumentType[\"MAPPING\"] = \"MAPPING\";\n    EDocumentType[\"BUDGET\"] = \"BUDGET\";\n})(EDocumentType || (EDocumentType = {}));\nfunction aggregateByTags(lines, tagLevel, excludeTag) {\n    let agregate = {};\n    let isRecursive = tagLevel < 0;\n    for(let i = 0; i < lines.length; i++){\n        const line = lines[i];\n        let idx = excludeTag === \"\" ? 0 : line.tags.indexOf(excludeTag);\n        let level = isRecursive ? idx % line.tags.length : tagLevel;\n        let tag = line.tags[level];\n        if (tag === excludeTag && level < line.tags.length - 1) {\n            tag = line.tags[level + 1];\n        } else if (tag === excludeTag && level === line.tags.length - 1) {\n            tag = isRecursive ? line.tags[0] : \"Undefined\";\n        }\n        if (tag in agregate) {\n            var _line_credit;\n            agregate[tag].credit += (_line_credit = line.credit) !== null && _line_credit !== void 0 ? _line_credit : 0;\n            var _line_debit;\n            agregate[tag].debit += (_line_debit = line.debit) !== null && _line_debit !== void 0 ? _line_debit : 0;\n        } else {\n            var _line_credit1, _line_debit1;\n            agregate[tag] = {\n                credit: (_line_credit1 = line.credit) !== null && _line_credit1 !== void 0 ? _line_credit1 : 0,\n                debit: (_line_debit1 = line.debit) !== null && _line_debit1 !== void 0 ? _line_debit1 : 0,\n                subTags: {}\n            };\n        }\n    }\n    return agregate;\n}\nfunction extractTags(lines) {\n    let tags = [];\n    for(let i = 0; i < lines.length; i++){\n        tags.push(...lines[i].tags);\n    }\n    // Remove duplicates\n    tags = tags.filter(function(tag, idx) {\n        return tags.indexOf(tag) === idx;\n    });\n    return tags.sort();\n}\nfunction extractTagsWithCount(lines) {\n    let tags = [];\n    for(let i = 0; i < lines.length; i++){\n        for(let j = 0; j < lines[i].tags.length; j++){\n            const tagIdx = tags.findIndex((tag)=>tag.tag === lines[i].tags[j]);\n            if (tagIdx === -1) {\n                tags.push({\n                    tag: lines[i].tags[j],\n                    count: 1,\n                    frequency: 1 / lines.length\n                });\n            } else {\n                tags[tagIdx].count++;\n                tags[tagIdx].frequency = tags[tagIdx].count / lines.length;\n            }\n        }\n    }\n    return tags.sort((a, b)=>{\n        const freqA = Math.floor(a.frequency * 100);\n        const freqB = Math.floor(b.frequency * 100);\n        if (freqA === freqB) {\n            return a.tag > b.tag ? 1 : -1;\n        }\n        return Math.floor(b.frequency * 100) - Math.floor(a.frequency * 100);\n    });\n}\nfunction aggregateByTag(lines, tag) {\n    let agregate = {};\n    const taggedLines = tag === \"\" ? lines : lines.filter((line)=>line.tags.indexOf(tag) !== -1);\n    for(let i = 0; i < taggedLines.length; i++){\n        const line = taggedLines[i];\n        if (tag in agregate) {\n            var _line_credit;\n            agregate[tag].credit += (_line_credit = line.credit) !== null && _line_credit !== void 0 ? _line_credit : 0;\n            var _line_debit;\n            agregate[tag].debit += (_line_debit = line.debit) !== null && _line_debit !== void 0 ? _line_debit : 0;\n        } else {\n            var _line_credit1, _line_debit1;\n            agregate[tag] = {\n                credit: (_line_credit1 = line.credit) !== null && _line_credit1 !== void 0 ? _line_credit1 : 0,\n                debit: (_line_debit1 = line.debit) !== null && _line_debit1 !== void 0 ? _line_debit1 : 0,\n                subTags: {}\n            };\n        }\n    }\n    agregate[tag].subTags = aggregateByTags(taggedLines, 0, tag);\n    return agregate;\n}\nfunction aggregateByDate(lines) {\n    let monthly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    let agregate = {};\n    for(let i = 0; i < lines.length; i++){\n        const line = lines[i];\n        let strDate = line.date.toLocaleDateString(\"fr-FR\");\n        if (monthly) {\n            strDate = strDate.slice(strDate.indexOf(\"/\") + 1);\n        }\n        if (strDate in agregate) {\n            var _line_credit;\n            agregate[strDate].credit += (_line_credit = line.credit) !== null && _line_credit !== void 0 ? _line_credit : 0;\n            var _line_debit;\n            agregate[strDate].debit += (_line_debit = line.debit) !== null && _line_debit !== void 0 ? _line_debit : 0;\n        } else {\n            var _line_credit1, _line_debit1;\n            agregate[strDate] = {\n                credit: (_line_credit1 = line.credit) !== null && _line_credit1 !== void 0 ? _line_credit1 : 0,\n                debit: (_line_debit1 = line.debit) !== null && _line_debit1 !== void 0 ? _line_debit1 : 0,\n                subTags: {}\n            };\n        }\n    }\n    return agregate;\n}\nfunction getAccountPeriodStr(account) {\n    let aggregatedMention = account.isAggregated ? \" (Aggregated) \" : \"\";\n    return account.begin.toLocaleDateString() + \" - \" + account.end.toLocaleDateString() + aggregatedMention;\n}\nfunction getWholePeriod(accounts) {\n    const wholePeriod = accounts.reduce((result, period)=>{\n        return {\n            ...result,\n            begin: period.begin < result.begin ? period.begin : result.begin,\n            end: period.begin > result.begin ? period.begin : result.begin,\n            lines: [\n                ...result.lines,\n                ...period.lines\n            ],\n            isAggregated: true\n        };\n    });\n    wholePeriod.lines.sort((a, b)=>{\n        return a.date > b.date ? 1 : -1;\n    });\n    return wholePeriod;\n}\nfunction isPaymentLabel(label) {\n    const regExp = new RegExp(/(PAIEMENT\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction isDirectDebitLabel(label) {\n    const regExp = new RegExp(/(PRLV\\sSEPA\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction isBankTransferLabel(label) {\n    const regExp = new RegExp(/(VIR\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction isWithdrawalLabel(label) {\n    const regExp = new RegExp(/(RETRAIT\\sDAB\\s)/);\n    const test = regExp.test(label.toUpperCase());\n    return test;\n}\nfunction getPaymentId(label) {\n    //PAIEMENT CB 3007 FR LYON LA-BARGE CARTE 2178\n    const matches = label.toUpperCase().match(/(?:PAIEMENT\\s(?:CB|PSC)\\s\\d\\d\\d\\d\\s)(([a-zA-Z]|-|_|\\d+|\\/|\\*|\\s)+)(?:CARTE\\s\\d\\d\\d\\d)/);\n    return matches ? matches[1] : \"\";\n}\nfunction getDirectDebitId(label) {\n    const matches = label.toUpperCase().match(/(?:PRLV\\sSEPA\\s)(([a-zA-Z]|-|_|\\s)+)/);\n    return matches ? matches[1] : \"\";\n}\nfunction getBankTransferId(label) {\n    const matches = label.toUpperCase().match(/(?:VIR\\s)(([a-zA-Z]|-|_|\\s)+)/);\n    return matches ? matches[1] : \"\";\n}\nfunction getWithdrawalId(label) {\n    const matches = label.toUpperCase().match(/RETRAIT DAB/);\n    return matches ? matches[0] : \"\";\n}\nfunction extractIdFromLabel(label) {\n    if (isBankTransferLabel(label)) {\n        return getBankTransferId(label).trim();\n    }\n    if (isPaymentLabel(label)) {\n        return getPaymentId(label).trim();\n    }\n    if (isDirectDebitLabel(label)) {\n        return getDirectDebitId(label).trim();\n    }\n    if (isWithdrawalLabel(label)) {\n        return getWithdrawalId(label).trim();\n    }\n    return label.trim();\n}\nfunction tagPeriods(periods, mapping) {\n    const taggedPeriods = [\n        ...periods\n    ];\n    for(let i = 0; i < taggedPeriods.length; i++){\n        const period = taggedPeriods[i];\n        for(let j = 0; j < period.lines.length; j++){\n            const line = period.lines[j];\n            const id = extractIdFromLabel(line.label);\n            if (mapping[id]) {\n                line.tags = mapping[id].split(\">\");\n            }\n        }\n    }\n    return taggedPeriods;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvRGF0YS9CYW5rLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUEwQ1lBOzs7O0dBQUFBLGtCQUFBQTtBQU1MLFNBQVNDLGdCQUFnQkMsS0FBcUIsRUFBRUMsUUFBZ0IsRUFBRUMsVUFBa0I7SUFDdkYsSUFBSUMsV0FBb0IsQ0FBQztJQUN6QixJQUFJQyxjQUFjSCxXQUFXO0lBRTdCLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7UUFDbkMsTUFBTUUsT0FBT1AsS0FBSyxDQUFDSyxFQUFFO1FBRXJCLElBQUlHLE1BQU1OLGVBQWUsS0FBSyxJQUFJSyxLQUFLRSxJQUFJLENBQUNDLE9BQU8sQ0FBQ1I7UUFDcEQsSUFBSVMsUUFBUVAsY0FBZUksTUFBTUQsS0FBS0UsSUFBSSxDQUFDSCxNQUFNLEdBQUlMO1FBQ3JELElBQUlXLE1BQU1MLEtBQUtFLElBQUksQ0FBQ0UsTUFBTTtRQUUxQixJQUFJQyxRQUFRVixjQUFjUyxRQUFTSixLQUFLRSxJQUFJLENBQUNILE1BQU0sR0FBRyxHQUFJO1lBQ3RETSxNQUFNTCxLQUFLRSxJQUFJLENBQUNFLFFBQVEsRUFBRTtRQUM5QixPQUNLLElBQUlDLFFBQVFWLGNBQWNTLFVBQVdKLEtBQUtFLElBQUksQ0FBQ0gsTUFBTSxHQUFHLEdBQUk7WUFDN0RNLE1BQU1SLGNBQWNHLEtBQUtFLElBQUksQ0FBQyxFQUFFLEdBQUc7UUFDdkM7UUFFQSxJQUFJRyxPQUFPVCxVQUFVO2dCQUNPSTtZQUF4QkosUUFBUSxDQUFDUyxJQUFJLENBQUNDLE1BQU0sSUFBSU4sQ0FBQUEsZUFBQUEsS0FBS00sTUFBTSxjQUFYTiwwQkFBQUEsZUFBZTtnQkFDaEJBO1lBQXZCSixRQUFRLENBQUNTLElBQUksQ0FBQ0UsS0FBSyxJQUFJUCxDQUFBQSxjQUFBQSxLQUFLTyxLQUFLLGNBQVZQLHlCQUFBQSxjQUFjO1FBQ3pDLE9BQ0s7Z0JBRVdBLGVBQ0RBO1lBRlhKLFFBQVEsQ0FBQ1MsSUFBSSxHQUFHO2dCQUNaQyxRQUFRTixDQUFBQSxnQkFBQUEsS0FBS00sTUFBTSxjQUFYTiwyQkFBQUEsZ0JBQWU7Z0JBQ3ZCTyxPQUFPUCxDQUFBQSxlQUFBQSxLQUFLTyxLQUFLLGNBQVZQLDBCQUFBQSxlQUFjO2dCQUNyQlEsU0FBUyxDQUFDO1lBQ2Q7UUFDSjtJQUNKO0lBRUEsT0FBT1o7QUFDWDtBQUVPLFNBQVNhLFlBQVloQixLQUFxQjtJQUM3QyxJQUFJUyxPQUFpQixFQUFFO0lBQ3ZCLElBQUssSUFBSUosSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7UUFDbkNJLEtBQUtRLElBQUksSUFBSWpCLEtBQUssQ0FBQ0ssRUFBRSxDQUFDSSxJQUFJO0lBQzlCO0lBRUEsb0JBQW9CO0lBQ3BCQSxPQUFPQSxLQUFLUyxNQUFNLENBQUMsU0FBU04sR0FBRyxFQUFFSixHQUFHO1FBQ2hDLE9BQU9DLEtBQUtDLE9BQU8sQ0FBQ0UsU0FBU0o7SUFDakM7SUFFQSxPQUFPQyxLQUFLVSxJQUFJO0FBQ3BCO0FBRU8sU0FBU0MscUJBQXFCcEIsS0FBcUI7SUFDdEQsSUFBSVMsT0FBZSxFQUFFO0lBQ3JCLElBQUssSUFBSUosSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7UUFDbkMsSUFBSyxJQUFJZ0IsSUFBSSxHQUFHQSxJQUFJckIsS0FBSyxDQUFDSyxFQUFFLENBQUNJLElBQUksQ0FBQ0gsTUFBTSxFQUFFZSxJQUFLO1lBQzNDLE1BQU1DLFNBQVNiLEtBQUtjLFNBQVMsQ0FBQyxDQUFDWCxNQUFRQSxJQUFJQSxHQUFHLEtBQUtaLEtBQUssQ0FBQ0ssRUFBRSxDQUFDSSxJQUFJLENBQUNZLEVBQUU7WUFDbkUsSUFBSUMsV0FBVyxDQUFDLEdBQUc7Z0JBQ2ZiLEtBQUtRLElBQUksQ0FBQztvQkFBQ0wsS0FBS1osS0FBSyxDQUFDSyxFQUFFLENBQUNJLElBQUksQ0FBQ1ksRUFBRTtvQkFBRUcsT0FBTztvQkFBR0MsV0FBVyxJQUFFekIsTUFBTU0sTUFBTTtnQkFBQTtZQUN6RSxPQUNLO2dCQUNERyxJQUFJLENBQUNhLE9BQU8sQ0FBQ0UsS0FBSztnQkFDbEJmLElBQUksQ0FBQ2EsT0FBTyxDQUFDRyxTQUFTLEdBQUdoQixJQUFJLENBQUNhLE9BQU8sQ0FBQ0UsS0FBSyxHQUFDeEIsTUFBTU0sTUFBTTtZQUM1RDtRQUNKO0lBQ0o7SUFFQSxPQUFPRyxLQUFLVSxJQUFJLENBQUMsQ0FBQ08sR0FBR0M7UUFDakIsTUFBTUMsUUFBUUMsS0FBS0MsS0FBSyxDQUFDSixFQUFFRCxTQUFTLEdBQUc7UUFDdkMsTUFBTU0sUUFBUUYsS0FBS0MsS0FBSyxDQUFDSCxFQUFFRixTQUFTLEdBQUc7UUFDdkMsSUFBSUcsVUFBVUcsT0FBTztZQUNqQixPQUFPTCxFQUFFZCxHQUFHLEdBQUdlLEVBQUVmLEdBQUcsR0FBRyxJQUFJLENBQUM7UUFDaEM7UUFDQSxPQUFRaUIsS0FBS0MsS0FBSyxDQUFDSCxFQUFFRixTQUFTLEdBQUcsT0FBT0ksS0FBS0MsS0FBSyxDQUFDSixFQUFFRCxTQUFTLEdBQUc7SUFDckU7QUFDSjtBQUVPLFNBQVNPLGVBQWVoQyxLQUFxQixFQUFFWSxHQUFXO0lBQzdELElBQUlULFdBQW9CLENBQUM7SUFDekIsTUFBTThCLGNBQWNyQixRQUFRLEtBQUtaLFFBQVFBLE1BQU1rQixNQUFNLENBQUMsQ0FBQ1gsT0FBU0EsS0FBS0UsSUFBSSxDQUFDQyxPQUFPLENBQUNFLFNBQVMsQ0FBQztJQUU1RixJQUFLLElBQUlQLElBQUksR0FBR0EsSUFBSTRCLFlBQVkzQixNQUFNLEVBQUVELElBQUs7UUFDekMsTUFBTUUsT0FBTzBCLFdBQVcsQ0FBQzVCLEVBQUU7UUFDM0IsSUFBSU8sT0FBT1QsVUFBVTtnQkFDT0k7WUFBeEJKLFFBQVEsQ0FBQ1MsSUFBSSxDQUFDQyxNQUFNLElBQUlOLENBQUFBLGVBQUFBLEtBQUtNLE1BQU0sY0FBWE4sMEJBQUFBLGVBQWU7Z0JBQ2hCQTtZQUF2QkosUUFBUSxDQUFDUyxJQUFJLENBQUNFLEtBQUssSUFBSVAsQ0FBQUEsY0FBQUEsS0FBS08sS0FBSyxjQUFWUCx5QkFBQUEsY0FBYztRQUN6QyxPQUNLO2dCQUVXQSxlQUNEQTtZQUZYSixRQUFRLENBQUNTLElBQUksR0FBRztnQkFDWkMsUUFBUU4sQ0FBQUEsZ0JBQUFBLEtBQUtNLE1BQU0sY0FBWE4sMkJBQUFBLGdCQUFlO2dCQUN2Qk8sT0FBT1AsQ0FBQUEsZUFBQUEsS0FBS08sS0FBSyxjQUFWUCwwQkFBQUEsZUFBYztnQkFDckJRLFNBQVMsQ0FBQztZQUNkO1FBQ0o7SUFDSjtJQUNBWixRQUFRLENBQUNTLElBQUksQ0FBQ0csT0FBTyxHQUFHaEIsZ0JBQWdCa0MsYUFBYSxHQUFHckI7SUFDeEQsT0FBT1Q7QUFDWDtBQUVPLFNBQVMrQixnQkFBZ0JsQyxLQUFxQjtRQUFFbUMsVUFBQUEsaUVBQW1CO0lBQ3RFLElBQUloQyxXQUFvQixDQUFDO0lBRXpCLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7UUFDbkMsTUFBTUUsT0FBT1AsS0FBSyxDQUFDSyxFQUFFO1FBQ3JCLElBQUkrQixVQUFVN0IsS0FBSzhCLElBQUksQ0FBQ0Msa0JBQWtCLENBQUM7UUFDM0MsSUFBSUgsU0FBUztZQUNUQyxVQUFVQSxRQUFRRyxLQUFLLENBQUNILFFBQVExQixPQUFPLENBQUMsT0FBSztRQUNqRDtRQUVBLElBQUkwQixXQUFXakMsVUFBVTtnQkFDT0k7WUFBNUJKLFFBQVEsQ0FBQ2lDLFFBQVEsQ0FBQ3ZCLE1BQU0sSUFBSU4sQ0FBQUEsZUFBQUEsS0FBS00sTUFBTSxjQUFYTiwwQkFBQUEsZUFBZTtnQkFDaEJBO1lBQTNCSixRQUFRLENBQUNpQyxRQUFRLENBQUN0QixLQUFLLElBQUlQLENBQUFBLGNBQUFBLEtBQUtPLEtBQUssY0FBVlAseUJBQUFBLGNBQWM7UUFDN0MsT0FDSztnQkFFV0EsZUFDREE7WUFGWEosUUFBUSxDQUFDaUMsUUFBUSxHQUFHO2dCQUNoQnZCLFFBQVFOLENBQUFBLGdCQUFBQSxLQUFLTSxNQUFNLGNBQVhOLDJCQUFBQSxnQkFBZTtnQkFDdkJPLE9BQU9QLENBQUFBLGVBQUFBLEtBQUtPLEtBQUssY0FBVlAsMEJBQUFBLGVBQWM7Z0JBQ3JCUSxTQUFTLENBQUM7WUFDZDtRQUNKO0lBQ0o7SUFDQSxPQUFPWjtBQUNYO0FBRU8sU0FBU3FDLG9CQUFvQkMsT0FBdUI7SUFDdkQsSUFBSUMsb0JBQW9CRCxRQUFRRSxZQUFZLEdBQUcsbUJBQW1CO0lBQ2xFLE9BQU9GLFFBQVFHLEtBQUssQ0FBQ04sa0JBQWtCLEtBQUssUUFBUUcsUUFBUUksR0FBRyxDQUFDUCxrQkFBa0IsS0FBS0k7QUFDM0Y7QUFFTyxTQUFTSSxlQUFlQyxRQUEwQjtJQUNyRCxNQUFNQyxjQUE4QkQsU0FBU0UsTUFBTSxDQUFDLENBQUNDLFFBQVFDO1FBQ3pELE9BQU87WUFBQyxHQUFHRCxNQUFNO1lBQ2JOLE9BQU9PLE9BQU9QLEtBQUssR0FBR00sT0FBT04sS0FBSyxHQUFHTyxPQUFPUCxLQUFLLEdBQUdNLE9BQU9OLEtBQUs7WUFDaEVDLEtBQUtNLE9BQU9QLEtBQUssR0FBR00sT0FBT04sS0FBSyxHQUFHTyxPQUFPUCxLQUFLLEdBQUdNLE9BQU9OLEtBQUs7WUFDOUQ1QyxPQUFPO21CQUFJa0QsT0FBT2xELEtBQUs7bUJBQUttRCxPQUFPbkQsS0FBSzthQUFDO1lBQ3pDMkMsY0FBYztRQUFJO0lBQ3hCO0lBRUFLLFlBQVloRCxLQUFLLENBQUNtQixJQUFJLENBQUMsQ0FBQ08sR0FBaUJDO1FBQXFCLE9BQU9ELEVBQUVXLElBQUksR0FBR1YsRUFBRVUsSUFBSSxHQUFHLElBQUksQ0FBQztJQUFFO0lBQ2hHLE9BQU9XO0FBRVg7QUFFTyxTQUFTSSxlQUFlQyxLQUFhO0lBQ3hDLE1BQU1DLFNBQVMsSUFBSUMsT0FBTztJQUMxQixNQUFNQyxPQUFPRixPQUFPRSxJQUFJLENBQUNILE1BQU1JLFdBQVc7SUFDMUMsT0FBT0Q7QUFDWDtBQUVPLFNBQVNFLG1CQUFtQkwsS0FBYTtJQUM1QyxNQUFNQyxTQUFTLElBQUlDLE9BQU87SUFDMUIsTUFBTUMsT0FBT0YsT0FBT0UsSUFBSSxDQUFDSCxNQUFNSSxXQUFXO0lBQzFDLE9BQU9EO0FBQ1g7QUFFTyxTQUFTRyxvQkFBb0JOLEtBQWE7SUFDN0MsTUFBTUMsU0FBUyxJQUFJQyxPQUFPO0lBQzFCLE1BQU1DLE9BQU9GLE9BQU9FLElBQUksQ0FBQ0gsTUFBTUksV0FBVztJQUMxQyxPQUFPRDtBQUNYO0FBRU8sU0FBU0ksa0JBQWtCUCxLQUFhO0lBQzNDLE1BQU1DLFNBQVMsSUFBSUMsT0FBTztJQUMxQixNQUFNQyxPQUFPRixPQUFPRSxJQUFJLENBQUNILE1BQU1JLFdBQVc7SUFDMUMsT0FBT0Q7QUFDWDtBQUVPLFNBQVNLLGFBQWFSLEtBQWE7SUFDdEMsOENBQThDO0lBQzlDLE1BQU1TLFVBQVVULE1BQU1JLFdBQVcsR0FBR00sS0FBSyxDQUFDO0lBQzFDLE9BQU9ELFVBQVVBLE9BQU8sQ0FBQyxFQUFFLEdBQUc7QUFDbEM7QUFFTyxTQUFTRSxpQkFBaUJYLEtBQWE7SUFDMUMsTUFBTVMsVUFBVVQsTUFBTUksV0FBVyxHQUFHTSxLQUFLLENBQUM7SUFDMUMsT0FBT0QsVUFBVUEsT0FBTyxDQUFDLEVBQUUsR0FBRztBQUNsQztBQUVPLFNBQVNHLGtCQUFrQlosS0FBYTtJQUMzQyxNQUFNUyxVQUFVVCxNQUFNSSxXQUFXLEdBQUdNLEtBQUssQ0FBQztJQUMxQyxPQUFPRCxVQUFVQSxPQUFPLENBQUMsRUFBRSxHQUFHO0FBQ2xDO0FBRU8sU0FBU0ksZ0JBQWdCYixLQUFhO0lBQ3pDLE1BQU1TLFVBQVVULE1BQU1JLFdBQVcsR0FBR00sS0FBSyxDQUFDO0lBQzFDLE9BQU9ELFVBQVVBLE9BQU8sQ0FBQyxFQUFFLEdBQUc7QUFDbEM7QUFFTyxTQUFTSyxtQkFBbUJkLEtBQWE7SUFDNUMsSUFBSU0sb0JBQW9CTixRQUFRO1FBQzVCLE9BQU9ZLGtCQUFrQlosT0FBT2UsSUFBSTtJQUN4QztJQUVBLElBQUloQixlQUFlQyxRQUFRO1FBQ3ZCLE9BQU9RLGFBQWFSLE9BQU9lLElBQUk7SUFDbkM7SUFFQSxJQUFJVixtQkFBbUJMLFFBQVE7UUFDM0IsT0FBT1csaUJBQWlCWCxPQUFPZSxJQUFJO0lBQ3ZDO0lBRUEsSUFBSVIsa0JBQWtCUCxRQUFRO1FBQzFCLE9BQU9hLGdCQUFnQmIsT0FBT2UsSUFBSTtJQUN0QztJQUVBLE9BQU9mLE1BQU1lLElBQUk7QUFDckI7QUFFTyxTQUFTQyxXQUFXQyxPQUF5QixFQUFFQyxPQUFpQjtJQUNuRSxNQUFNQyxnQkFBZ0I7V0FBSUY7S0FBUTtJQUNsQyxJQUFLLElBQUlqRSxJQUFJLEdBQUdBLElBQUltRSxjQUFjbEUsTUFBTSxFQUFFRCxJQUFLO1FBQzNDLE1BQU04QyxTQUFTcUIsYUFBYSxDQUFDbkUsRUFBRTtRQUMvQixJQUFLLElBQUlnQixJQUFJLEdBQUdBLElBQUk4QixPQUFPbkQsS0FBSyxDQUFDTSxNQUFNLEVBQUVlLElBQUs7WUFDMUMsTUFBTWQsT0FBTzRDLE9BQU9uRCxLQUFLLENBQUNxQixFQUFFO1lBQzVCLE1BQU1vRCxLQUFLTixtQkFBbUI1RCxLQUFLOEMsS0FBSztZQUN4QyxJQUFJa0IsT0FBTyxDQUFDRSxHQUFHLEVBQUU7Z0JBQ2JsRSxLQUFLRSxJQUFJLEdBQUc4RCxPQUFPLENBQUNFLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDO1lBQ2xDO1FBQ0o7SUFDSjtJQUNBLE9BQU9GO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9EYXRhL0JhbmsudHM/NjcyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIElBY2NvdW50TGluZSB7XHJcbiAgICBkYXRlOiBEYXRlO1xyXG4gICAgZGViaXQ6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIGNyZWRpdDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgbGFiZWw6IHN0cmluZztcclxuICAgIGJhbGFuY2U6IG51bWJlcjtcclxuICAgIHRhZ3M6IHN0cmluZ1tdO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElBY2NvdW50TGluZXMge1xyXG4gICAgbGluZXM6IElBY2NvdW50TGluZVtdO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElBY2NvdW50UGVyaW9kIHtcclxuICAgIGJlZ2luOiBEYXRlO1xyXG4gICAgZW5kOiBEYXRlO1xyXG4gICAgbGluZXM6IElBY2NvdW50TGluZVtdO1xyXG4gICAgaXNBZ2dyZWdhdGVkOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBUTWFwcGluZyA9IHtbbWF0Y2g6IHN0cmluZ106IHN0cmluZ31cclxuZXhwb3J0IGludGVyZmFjZSBJTWFwcGluZ0xpbmUge1xyXG4gICAgbWF0Y2g6IHN0cmluZztcclxuICAgIHRhZ3M6IHN0cmluZztcclxufVxyXG5leHBvcnQgdHlwZSBUYWdMaW5lID0ge1tpZDogc3RyaW5nXToge2NyZWRpdDogbnVtYmVyLCBkZWJpdDogbnVtYmVyLCBzdWJUYWdzOiBUYWdMaW5lfTsgfVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJVGFnIHtcclxuICAgIHRhZzogc3RyaW5nO1xyXG4gICAgY291bnQ6IG51bWJlcjtcclxuICAgIGZyZXF1ZW5jeTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBUQnVkZ2V0ID0ge1t0YWc6IHN0cmluZ106IG51bWJlcn1cclxuZXhwb3J0IGludGVyZmFjZSBJVGFnQnVkZ2V0IHtcclxuICAgIHRhZzogc3RyaW5nO1xyXG4gICAgYWxsb3dlZDogbnVtYmVyO1xyXG4gICAgY29uc3VtZWQ6IG51bWJlcjtcclxuICAgIGxpbmVzOiBJQWNjb3VudExpbmVbXTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBlbnVtIEVEb2N1bWVudFR5cGUge1xyXG4gICAgQUNDT1VOVCA9IFwiQUNDT1VOVFwiLFxyXG4gICAgTUFQUElORyA9IFwiTUFQUElOR1wiLFxyXG4gICAgQlVER0VUID0gXCJCVURHRVRcIixcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFnZ3JlZ2F0ZUJ5VGFncyhsaW5lczogSUFjY291bnRMaW5lW10sIHRhZ0xldmVsOiBudW1iZXIsIGV4Y2x1ZGVUYWc6IHN0cmluZyk6IFRhZ0xpbmUge1xyXG4gICAgbGV0IGFncmVnYXRlOiBUYWdMaW5lID0ge307XHJcbiAgICBsZXQgaXNSZWN1cnNpdmUgPSB0YWdMZXZlbCA8IDA7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcclxuXHJcbiAgICAgICAgbGV0IGlkeCA9IGV4Y2x1ZGVUYWcgPT09IFwiXCIgPyAwIDogbGluZS50YWdzLmluZGV4T2YoZXhjbHVkZVRhZyk7XHJcbiAgICAgICAgbGV0IGxldmVsID0gaXNSZWN1cnNpdmUgPyAoaWR4ICUgbGluZS50YWdzLmxlbmd0aCkgOiB0YWdMZXZlbDtcclxuICAgICAgICBsZXQgdGFnID0gbGluZS50YWdzW2xldmVsXTtcclxuXHJcbiAgICAgICAgaWYgKHRhZyA9PT0gZXhjbHVkZVRhZyAmJiBsZXZlbCA8IChsaW5lLnRhZ3MubGVuZ3RoIC0gMSkpIHtcclxuICAgICAgICAgICAgdGFnID0gbGluZS50YWdzW2xldmVsICsgMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gZXhjbHVkZVRhZyAmJiBsZXZlbCA9PT0gKGxpbmUudGFncy5sZW5ndGggLSAxKSkge1xyXG4gICAgICAgICAgICB0YWcgPSBpc1JlY3Vyc2l2ZSA/IGxpbmUudGFnc1swXSA6IFwiVW5kZWZpbmVkXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGFnIGluIGFncmVnYXRlKSB7XHJcbiAgICAgICAgICAgIGFncmVnYXRlW3RhZ10uY3JlZGl0ICs9IGxpbmUuY3JlZGl0ID8/IDA7XHJcbiAgICAgICAgICAgIGFncmVnYXRlW3RhZ10uZGViaXQgKz0gbGluZS5kZWJpdCA/PyAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWdyZWdhdGVbdGFnXSA9IHtcclxuICAgICAgICAgICAgICAgIGNyZWRpdDogbGluZS5jcmVkaXQgPz8gMCxcclxuICAgICAgICAgICAgICAgIGRlYml0OiBsaW5lLmRlYml0ID8/IDAsXHJcbiAgICAgICAgICAgICAgICBzdWJUYWdzOiB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhZ3JlZ2F0ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUYWdzKGxpbmVzOiBJQWNjb3VudExpbmVbXSk6IHN0cmluZ1tdIHtcclxuICAgIGxldCB0YWdzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRhZ3MucHVzaCguLi5saW5lc1tpXS50YWdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlc1xyXG4gICAgdGFncyA9IHRhZ3MuZmlsdGVyKGZ1bmN0aW9uKHRhZywgaWR4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRhZ3MuaW5kZXhPZih0YWcpID09PSBpZHg7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGFncy5zb3J0KCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VGFnc1dpdGhDb3VudChsaW5lczogSUFjY291bnRMaW5lW10pOiBJVGFnW10ge1xyXG4gICAgbGV0IHRhZ3M6IElUYWdbXSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXNbaV0udGFncy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBjb25zdCB0YWdJZHggPSB0YWdzLmZpbmRJbmRleCgodGFnKSA9PiB0YWcudGFnID09PSBsaW5lc1tpXS50YWdzW2pdKTtcclxuICAgICAgICAgICAgaWYgKHRhZ0lkeCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRhZ3MucHVzaCh7dGFnOiBsaW5lc1tpXS50YWdzW2pdLCBjb3VudDogMSwgZnJlcXVlbmN5OiAxL2xpbmVzLmxlbmd0aH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGFnc1t0YWdJZHhdLmNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB0YWdzW3RhZ0lkeF0uZnJlcXVlbmN5ID0gdGFnc1t0YWdJZHhdLmNvdW50L2xpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFncy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZnJlcUEgPSBNYXRoLmZsb29yKGEuZnJlcXVlbmN5ICogMTAwKTtcclxuICAgICAgICBjb25zdCBmcmVxQiA9IE1hdGguZmxvb3IoYi5mcmVxdWVuY3kgKiAxMDApO1xyXG4gICAgICAgIGlmIChmcmVxQSA9PT0gZnJlcUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEudGFnID4gYi50YWcgPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoTWF0aC5mbG9vcihiLmZyZXF1ZW5jeSAqIDEwMCkgLSBNYXRoLmZsb29yKGEuZnJlcXVlbmN5ICogMTAwKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFnZ3JlZ2F0ZUJ5VGFnKGxpbmVzOiBJQWNjb3VudExpbmVbXSwgdGFnOiBzdHJpbmcpOiBUYWdMaW5lIHtcclxuICAgIGxldCBhZ3JlZ2F0ZTogVGFnTGluZSA9IHt9O1xyXG4gICAgY29uc3QgdGFnZ2VkTGluZXMgPSB0YWcgPT09IFwiXCIgPyBsaW5lcyA6IGxpbmVzLmZpbHRlcigobGluZSkgPT4gbGluZS50YWdzLmluZGV4T2YodGFnKSAhPT0gLTEpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFnZ2VkTGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBsaW5lID0gdGFnZ2VkTGluZXNbaV07XHJcbiAgICAgICAgaWYgKHRhZyBpbiBhZ3JlZ2F0ZSkge1xyXG4gICAgICAgICAgICBhZ3JlZ2F0ZVt0YWddLmNyZWRpdCArPSBsaW5lLmNyZWRpdCA/PyAwO1xyXG4gICAgICAgICAgICBhZ3JlZ2F0ZVt0YWddLmRlYml0ICs9IGxpbmUuZGViaXQgPz8gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFncmVnYXRlW3RhZ10gPSB7XHJcbiAgICAgICAgICAgICAgICBjcmVkaXQ6IGxpbmUuY3JlZGl0ID8/IDAsXHJcbiAgICAgICAgICAgICAgICBkZWJpdDogbGluZS5kZWJpdCA/PyAwLFxyXG4gICAgICAgICAgICAgICAgc3ViVGFnczoge31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFncmVnYXRlW3RhZ10uc3ViVGFncyA9IGFnZ3JlZ2F0ZUJ5VGFncyh0YWdnZWRMaW5lcywgMCwgdGFnKTtcclxuICAgIHJldHVybiBhZ3JlZ2F0ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFnZ3JlZ2F0ZUJ5RGF0ZShsaW5lczogSUFjY291bnRMaW5lW10sIG1vbnRobHk6IGJvb2xlYW4gPSBmYWxzZSk6IFRhZ0xpbmUge1xyXG4gICAgbGV0IGFncmVnYXRlOiBUYWdMaW5lID0ge307XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcclxuICAgICAgICBsZXQgc3RyRGF0ZSA9IGxpbmUuZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoXCJmci1GUlwiKTtcclxuICAgICAgICBpZiAobW9udGhseSkge1xyXG4gICAgICAgICAgICBzdHJEYXRlID0gc3RyRGF0ZS5zbGljZShzdHJEYXRlLmluZGV4T2YoXCIvXCIpKzEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3RyRGF0ZSBpbiBhZ3JlZ2F0ZSkge1xyXG4gICAgICAgICAgICBhZ3JlZ2F0ZVtzdHJEYXRlXS5jcmVkaXQgKz0gbGluZS5jcmVkaXQgPz8gMDtcclxuICAgICAgICAgICAgYWdyZWdhdGVbc3RyRGF0ZV0uZGViaXQgKz0gbGluZS5kZWJpdCA/PyAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWdyZWdhdGVbc3RyRGF0ZV0gPSB7XHJcbiAgICAgICAgICAgICAgICBjcmVkaXQ6IGxpbmUuY3JlZGl0ID8/IDAsXHJcbiAgICAgICAgICAgICAgICBkZWJpdDogbGluZS5kZWJpdCA/PyAwLFxyXG4gICAgICAgICAgICAgICAgc3ViVGFnczoge31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhZ3JlZ2F0ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjY291bnRQZXJpb2RTdHIoYWNjb3VudDogSUFjY291bnRQZXJpb2QpOiBzdHJpbmcge1xyXG4gICAgbGV0IGFnZ3JlZ2F0ZWRNZW50aW9uID0gYWNjb3VudC5pc0FnZ3JlZ2F0ZWQgPyBcIiAoQWdncmVnYXRlZCkgXCIgOiBcIlwiO1xyXG4gICAgcmV0dXJuIGFjY291bnQuYmVnaW4udG9Mb2NhbGVEYXRlU3RyaW5nKCkgKyBcIiAtIFwiICsgYWNjb3VudC5lbmQudG9Mb2NhbGVEYXRlU3RyaW5nKCkgKyBhZ2dyZWdhdGVkTWVudGlvbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFdob2xlUGVyaW9kKGFjY291bnRzOiBJQWNjb3VudFBlcmlvZFtdKTogSUFjY291bnRQZXJpb2Qge1xyXG4gICAgY29uc3Qgd2hvbGVQZXJpb2Q6IElBY2NvdW50UGVyaW9kID0gYWNjb3VudHMucmVkdWNlKChyZXN1bHQsIHBlcmlvZCkgPT4ge1xyXG4gICAgICAgIHJldHVybiB7Li4ucmVzdWx0LFxyXG4gICAgICAgICAgICBiZWdpbjogcGVyaW9kLmJlZ2luIDwgcmVzdWx0LmJlZ2luID8gcGVyaW9kLmJlZ2luIDogcmVzdWx0LmJlZ2luLFxyXG4gICAgICAgICAgICBlbmQ6IHBlcmlvZC5iZWdpbiA+IHJlc3VsdC5iZWdpbiA/IHBlcmlvZC5iZWdpbiA6IHJlc3VsdC5iZWdpbixcclxuICAgICAgICAgICAgbGluZXM6IFsuLi5yZXN1bHQubGluZXMsIC4uLnBlcmlvZC5saW5lc10sXHJcbiAgICAgICAgICAgIGlzQWdncmVnYXRlZDogdHJ1ZX1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICB3aG9sZVBlcmlvZC5saW5lcy5zb3J0KChhOiBJQWNjb3VudExpbmUsIGI6IElBY2NvdW50TGluZSkgPT4ge3JldHVybiBhLmRhdGUgPiBiLmRhdGUgPyAxIDogLTE7fSk7XHJcbiAgICByZXR1cm4gd2hvbGVQZXJpb2Q7XHJcblxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNQYXltZW50TGFiZWwobGFiZWw6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cCgvKFBBSUVNRU5UXFxzKS8pO1xyXG4gICAgY29uc3QgdGVzdCA9IHJlZ0V4cC50ZXN0KGxhYmVsLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgcmV0dXJuIHRlc3Q7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0RpcmVjdERlYml0TGFiZWwobGFiZWw6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgcmVnRXhwID0gbmV3IFJlZ0V4cCgvKFBSTFZcXHNTRVBBXFxzKS8pO1xyXG4gICAgY29uc3QgdGVzdCA9IHJlZ0V4cC50ZXN0KGxhYmVsLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgcmV0dXJuIHRlc3Q7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0JhbmtUcmFuc2ZlckxhYmVsKGxhYmVsOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHJlZ0V4cCA9IG5ldyBSZWdFeHAoLyhWSVJcXHMpLyk7XHJcbiAgICBjb25zdCB0ZXN0ID0gcmVnRXhwLnRlc3QobGFiZWwudG9VcHBlckNhc2UoKSk7XHJcbiAgICByZXR1cm4gdGVzdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzV2l0aGRyYXdhbExhYmVsKGxhYmVsOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHJlZ0V4cCA9IG5ldyBSZWdFeHAoLyhSRVRSQUlUXFxzREFCXFxzKS8pO1xyXG4gICAgY29uc3QgdGVzdCA9IHJlZ0V4cC50ZXN0KGxhYmVsLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgcmV0dXJuIHRlc3Q7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXltZW50SWQobGFiZWw6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAvL1BBSUVNRU5UIENCIDMwMDcgRlIgTFlPTiBMQS1CQVJHRSBDQVJURSAyMTc4XHJcbiAgICBjb25zdCBtYXRjaGVzID0gbGFiZWwudG9VcHBlckNhc2UoKS5tYXRjaCgvKD86UEFJRU1FTlRcXHMoPzpDQnxQU0MpXFxzXFxkXFxkXFxkXFxkXFxzKSgoW2EtekEtWl18LXxffFxcZCt8XFwvfFxcKnxcXHMpKykoPzpDQVJURVxcc1xcZFxcZFxcZFxcZCkvKTtcclxuICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6IFwiXCI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREaXJlY3REZWJpdElkKGxhYmVsOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgbWF0Y2hlcyA9IGxhYmVsLnRvVXBwZXJDYXNlKCkubWF0Y2goLyg/OlBSTFZcXHNTRVBBXFxzKSgoW2EtekEtWl18LXxffFxccykrKS8pO1xyXG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzFdIDogXCJcIjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJhbmtUcmFuc2ZlcklkKGxhYmVsOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgbWF0Y2hlcyA9IGxhYmVsLnRvVXBwZXJDYXNlKCkubWF0Y2goLyg/OlZJUlxccykoKFthLXpBLVpdfC18X3xcXHMpKykvKTtcclxuICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6IFwiXCI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXaXRoZHJhd2FsSWQobGFiZWw6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBtYXRjaGVzID0gbGFiZWwudG9VcHBlckNhc2UoKS5tYXRjaCgvUkVUUkFJVCBEQUIvKTtcclxuICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1swXSA6IFwiXCI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SWRGcm9tTGFiZWwobGFiZWw6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBpZiAoaXNCYW5rVHJhbnNmZXJMYWJlbChsYWJlbCkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0QmFua1RyYW5zZmVySWQobGFiZWwpLnRyaW0oKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNQYXltZW50TGFiZWwobGFiZWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFBheW1lbnRJZChsYWJlbCkudHJpbSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0RpcmVjdERlYml0TGFiZWwobGFiZWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldERpcmVjdERlYml0SWQobGFiZWwpLnRyaW0oKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNXaXRoZHJhd2FsTGFiZWwobGFiZWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFdpdGhkcmF3YWxJZChsYWJlbCkudHJpbSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYWJlbC50cmltKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0YWdQZXJpb2RzKHBlcmlvZHM6IElBY2NvdW50UGVyaW9kW10sIG1hcHBpbmc6IFRNYXBwaW5nKTogSUFjY291bnRQZXJpb2RbXSB7XHJcbiAgICBjb25zdCB0YWdnZWRQZXJpb2RzID0gWy4uLnBlcmlvZHNdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWdnZWRQZXJpb2RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcGVyaW9kID0gdGFnZ2VkUGVyaW9kc1tpXTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBlcmlvZC5saW5lcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lID0gcGVyaW9kLmxpbmVzW2pdO1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IGV4dHJhY3RJZEZyb21MYWJlbChsaW5lLmxhYmVsKTtcclxuICAgICAgICAgICAgaWYgKG1hcHBpbmdbaWRdKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lLnRhZ3MgPSBtYXBwaW5nW2lkXS5zcGxpdCgnPicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhZ2dlZFBlcmlvZHM7XHJcbn0iXSwibmFtZXMiOlsiRURvY3VtZW50VHlwZSIsImFnZ3JlZ2F0ZUJ5VGFncyIsImxpbmVzIiwidGFnTGV2ZWwiLCJleGNsdWRlVGFnIiwiYWdyZWdhdGUiLCJpc1JlY3Vyc2l2ZSIsImkiLCJsZW5ndGgiLCJsaW5lIiwiaWR4IiwidGFncyIsImluZGV4T2YiLCJsZXZlbCIsInRhZyIsImNyZWRpdCIsImRlYml0Iiwic3ViVGFncyIsImV4dHJhY3RUYWdzIiwicHVzaCIsImZpbHRlciIsInNvcnQiLCJleHRyYWN0VGFnc1dpdGhDb3VudCIsImoiLCJ0YWdJZHgiLCJmaW5kSW5kZXgiLCJjb3VudCIsImZyZXF1ZW5jeSIsImEiLCJiIiwiZnJlcUEiLCJNYXRoIiwiZmxvb3IiLCJmcmVxQiIsImFnZ3JlZ2F0ZUJ5VGFnIiwidGFnZ2VkTGluZXMiLCJhZ2dyZWdhdGVCeURhdGUiLCJtb250aGx5Iiwic3RyRGF0ZSIsImRhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJzbGljZSIsImdldEFjY291bnRQZXJpb2RTdHIiLCJhY2NvdW50IiwiYWdncmVnYXRlZE1lbnRpb24iLCJpc0FnZ3JlZ2F0ZWQiLCJiZWdpbiIsImVuZCIsImdldFdob2xlUGVyaW9kIiwiYWNjb3VudHMiLCJ3aG9sZVBlcmlvZCIsInJlZHVjZSIsInJlc3VsdCIsInBlcmlvZCIsImlzUGF5bWVudExhYmVsIiwibGFiZWwiLCJyZWdFeHAiLCJSZWdFeHAiLCJ0ZXN0IiwidG9VcHBlckNhc2UiLCJpc0RpcmVjdERlYml0TGFiZWwiLCJpc0JhbmtUcmFuc2ZlckxhYmVsIiwiaXNXaXRoZHJhd2FsTGFiZWwiLCJnZXRQYXltZW50SWQiLCJtYXRjaGVzIiwibWF0Y2giLCJnZXREaXJlY3REZWJpdElkIiwiZ2V0QmFua1RyYW5zZmVySWQiLCJnZXRXaXRoZHJhd2FsSWQiLCJleHRyYWN0SWRGcm9tTGFiZWwiLCJ0cmltIiwidGFnUGVyaW9kcyIsInBlcmlvZHMiLCJtYXBwaW5nIiwidGFnZ2VkUGVyaW9kcyIsImlkIiwic3BsaXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Data/Bank.ts\n"));

/***/ })

});